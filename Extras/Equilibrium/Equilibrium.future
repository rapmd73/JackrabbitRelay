#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Jackrabbit Equilibrium
# 2021 Copyright Â© Robert APM Darin
# All rights reserved unconditionally.

# LONG -    buy when the price goes down
# SHORT -   buy when the price goes up

import sys
sys.path.append('/home/JackrabbitRelay/Base/Library')
import os
from datetime import datetime
import pathlib
import time
import requests
import json

import JRRconfig
import JRRlog
import JRRapi
import JRRsupport

Header='Equilibrium '+JRRconfig.Version

def SendWebhook(Active,exchangeName,market,account,orderType,pair,action,amount,price):
    exc='"Exchange":"'+exchangeName+'", "Market":"'+market+'"'
    account='"Account":"'+account+'", "OrderType":"'+orderType+'"'
    sym='"Asset":"'+pair+'"'
    direction='"Action":"'+action.lower()+'"'
    psize='"Base":"'+str(amount)+'"'+',"Close":"'+str(price)+'"'

    if "Identity" in Active:
        idl='"Identity":"'+Active['Identity']+'"'
        cmd='{ '+idl+', '+exc+', '+account+', '+direction+', '+sym+', '+psize+' }'
    else:
        cmd='{ '+exc+', '+account+', '+direction+', '+sym+', '+psize+' }'

    headers={'content-type': 'text/plain', 'Connection': 'close'}

    resp=None
    res=None
    try:
        resp=requests.post(Active['Webhook'],headers=headers,data=cmd)
        try:
            r=json.loads(resp.text)
            try:
                res=r['message']
            except:
                res=json.dumps(r)
        except:
            res=resp.text
    except:
        res=None

    return res

def GetOrderID(res):
    s=res.find('ID:')+4
    for e in range(s,len(res)):
        if res[e]=='\n':
            break
    oid=res[s:e]

    return oid

def CheckStopTracer(exchangeName,account,Asset):
    fn=exchangeName+'.'+account+'.'+Asset.replace("-","").replace("/","").replace(':','')+'.stop'
    if os.path.exists(fn):
        JRRlog.SuccessLog("STOP", "tracer detected")

def ReadGrid(exchangeName,account,Asset):
    fn=exchangeName+'.'+account+'.'+Asset.replace("-","").replace("/","").replace(':','')+'.grid'
    if os.path.exists(fn):
        JRRlog.WriteLog("Reading Grid file")
        fh=open(fn,'r')
        for line in fh:
            Trade={}
            Trade=json.loads(line.rstrip())
        fh.close()
        JRRlog.WriteLog(f"|- {Asset:10} {Trade['Buy']:.8f} {Trade['Close']:.8f} {Trade['Sell']:.8f}")
    else:
        Trade={}
        Trade['PCTValue']=0.0
        Trade['Close']=0.0
        Trade['Buy']=0.0
        Trade['Sell']=0.0
        Trade['Counter']=0
        Trade['Profit']=0.0

    return(Trade)

def WriteGrid(exchangeName,account,Trade,Asset):
    fn=exchangeName+'.'+account+'.'+Asset.replace("-","").replace("/","").replace(':','')+'.grid'

    if Trade['Counter']>0:
        fh=open(fn,'w')
        fh.write(json.dumps(Trade)+"\n")
        fh.close()
    else:
        if os.path.exists(fn):
            os.remove(fn)

def WriteFutureLog(e,a,p,d,msg):
    PlaceOrderName=os.path.basename(sys.argv[0])
    pn=e+'.'+a+'.'+p.replace("-","").replace("/","").replace(':','')

    pid=os.getpid()
    time=(datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f'))

    s=f'{time} {pid:7.0f} {msg}\n'

    fh=open(JRRconfig.LogDirectory+'/'+PlaceOrderName+'.'+d+'.'+pn+'.log','a')
    fh.write(s)
    fh.close()
    print(s.rstrip())
    sys.stdout.flush()

# Convert account balance to lots in steps

def Balance2Lots(exchange,pair,pct,RetryLimit):
    quote=exchange.markets[pair]['quote']
    if quote not in JRRconfig.StableCoinUSD:
        hasQuote=True
    else:
        hasQuote=False

# Get exchange required minimums

    minimum,mincost=JRRapi.GetMinimum(exchange,pair,hasQuote,False,RetryLimit)

# Convert balance to number of steps and lots

    bal=JRRapi.GetBalance(exchange,quote,RetryLimit)
    steps=100/(pct*100)
    priceStep=bal/steps
    Lots=priceStep/mincost
        
    if Lots<1:
        Lots=1

    return Lots

# Read CFG file

def ReadConfig(fn):
    Required=[ "Exchange", "Account", "Asset", "Boundary", "BuyLots","Direction" ]

    Config={}

    JRRlog.WriteLog("Reading configuration file")

    if os.path.exists(fn):
        try:
            raw=pathlib.Path(fn).read_text()
        except:
            JRRlog.ErrorLog("ReadConfig",f"Can't read {fn}")

        txt=JRRsupport.pFilter(raw)

        try:
            Config=json.loads(txt)
        except:
            JRRlog.ErrorLog("ReadConfig",f"Damaged JSON: {txt}")
    else:
        JRRlog.ErrorLog("ReadConfig",'Config file not found.')

    for i in Config:
        JRRlog.WriteLog(f"|- {i}: {Config[i]}")

    for i in Required:
        if i not in Config:
            JRRlog.ErrorLog("ReadConfig",f"Missing required item: {i}")

    Config['Exchange']=Config['Exchange'].lower()
    Config['Direction']=Config['Direction'].lower()
    Config['Asset']=Config['Asset'].upper()
    Config['Boundary']=float(Config['Boundary'])/100
    if "SellLots" not in Config:
        Config['SellLots']='Dynamic'
    if "OverSell" in Config:
        Config['OverSell']=float(Config['OverSell'])/100
    else:
        Config['OverSell']=20/100
    if "OrderType" not in Config:
        Config['OrderType']='Market'

    if "BuyStopHigh" in Config:
        Config['BuyStopHigh']=float(Config['BuyStopHigh'])
    else:
        Config['BuyStopHigh']=-1
    if "BuyStopLow" in Config:
        Config['BuyStopLow']=float(Config['BuyStopLow'])
    else:
        Config['BuyStopLow']=-1
    if "SellStopHigh" in Config:
        Config['SellStopHigh']=float(Config['SellStopHigh'])
    else:
        Config['SellStopHigh']=-1
    if "SellStopLow" in Config:
        Config['SellStopLow']=float(Config['SellStopLow'])
    else:
        Config['SellStopLow']=-1
    if "ExitProfit" in Config:
        Config['ExitProfit']=float(Config['ExitProfit'])
    else:
        Config['ExitProfit']=-1

    return(Config)

def TradeBuyAmount(Config,Trade,exchange,pair,pct,RetryLimit):
    minimum,mincost=JRRapi.GetMinimum(exchange,pair,False,False,RetryLimit)

    if Config['BuyLots'].lower()=='balance':
        Trade['BuyLots']=Balance2Lots(exchange,pair,pct,RetryLimit)
        Trade['BuyAmount']=Trade['BuyLots']*minimum
    else:
        Trade['BuyLots']=Config['BuyLots']
        p=float(Trade['BuyLots'])
        if p<1:
            p=1
        Trade['BuyAmount']=minimum*p

    return Trade

def TradeSellAmount(Config,Trade,exchange,pair,pct,RetryLimit):
    minimum,mincost=JRRapi.GetMinimum(exchange,pair,False,False,RetryLimit)

    if Config['SellLots'].lower()=='dynamic':
        if Trade['Counter']>0:
            pb=(Config['OverSell']/100)*(Trade['Counter']/(100*pct))*pct
            ba=float(Trade['BuyLots'])*minimum
            Trade['SellAmount']=ba+(ba*pb)
        else:
            Trade['SellAmount']=float(Trade['BuyAmount'])
    elif Config['SellLots'].lower()=='buylots':
        Trade['SellAmount']=float(Trade['BuyAmount'])
    else:
        Trade['SellAmount']=minimum*float(Config['SellLots'])

    return Trade

def CheckHighLow(c,l,h):
    if l==-1 and h==-1:
        return True

    if c>=l and h==-1:
        return True
    else:
        return False

    if l==-1 and c<=h:
        return True
    else:
        return False

    if c>=l and c<=h:
        return True
    else:
        return False

###
### Main code base. Place order on exchange
###

def main():
    JRRlog.WriteLog(Header)

    # Read CFG file
    if len(sys.argv) > 1:
        Config=ReadConfig(sys.argv[1])
    else:
        print("A valid configuration file must be provided.")
        sys.exit(1)

    once=False
    if len(sys.argv) > 2 and sys.argv[2].lower()=='once':
        once=True

    paper=False
    if 'Paper' in Config:
        paper=True

    exchangeName=Config['Exchange']
    account=Config['Account']
    pair=Config['Asset']
    pct=Config['Boundary']
    orderType=Config['OrderType']
    direction=Config['Direction']

# Figure out the direction of the trade

    if direction!='long' and direction!='short':
        JRRlog.ErrorLog("Equilibrium","Direction MUST be long or short")

# Theory:
#
# Long direction trading:
#       Buy when price is below boundary.   API: long
#       Sell when price is above boundary.  API: short
#
# Short direction trading:
#       Buy when price is above boundary.   API: short
#       Sell when price is below boundary.  API: long
#
# Realization: PCT value needs to be set to ATH like long positions.
#              Defensiveness is needed to stop excess accumulation.

    if direction=='long':
        BuyDir='long'
        SellDir='short'
    else:
        BuyDir='short'
        SellDir='long'
        AllTimeHigh=0.0

    keys=JRRsupport.ReadConfig(exchangeName,account)
    JRRlog.WriteLog("API(s)/Secret(s) loaded for "+exchangeName+", (sub)account: "+account)

    CurrentKey=(os.getpid()%len(keys))
    Active=keys[CurrentKey]

    exchange=JRRapi.ExchangeLogin(exchangeName,Active)

    if "Retry" in Active:
        RetryLimit=int(Active['Retry'])
        JRRlog.WriteLog("|- API Retry limit set to "+str(RetryLimit)+' times')
    else:
        RetryLimit=10

    if not "Webhook" in Active:
        JRRlog.ErrorLog("Equilibrium","Webhook NOT present")

    markets=JRRapi.GetMarkets(exchange,pair,RetryLimit)

# This is where a looping method would go if this were to serve a single exchange
# with multiple pairs.

# Get asset information

    base=exchange.markets[pair]['base']
    quote=exchange.markets[pair]['quote']

    marketType="future"
    if "type" in exchange.markets[pair]:
        if "type" in exchange.markets[pair]['info']:
            if exchange.markets[pair]['info']['type']==exchange.markets[pair]['type']:
                marketType=exchange.markets[pair]['type']
            else:
                marketType=exchange.markets[pair]['info']['type']

    JRRlog.WriteLog("Base currency:  "+base)
    JRRlog.WriteLog("Quote currency: "+quote)
    JRRlog.WriteLog("Trade direction: "+direction)

    AllTimeHigh=0.0
    Trade=ReadGrid(exchangeName,account,pair)
    if 'Profit' not in Trade:
        Trade['Profit']=0.0
    if 'BuyAmount' not in Trade:
        Trade=TradeBuyAmount(Config,Trade,exchange,pair,pct,RetryLimit)

    first=True
    while True:
        # Rotate the key

        CurrentKey=((CurrentKey+1)%len(keys))
        Active=keys[CurrentKey]
        JRRapi.SetExchangeAPI(exchange,Active)

        # Actual algorithm

        bal=JRRapi.GetContract(exchange,pair,RetryLimit)

        # Rotate the key

        CurrentKey=((CurrentKey+1)%len(keys))
        Active=keys[CurrentKey]
        JRRapi.SetExchangeAPI(exchange,Active)

        ohlcv,ticker=JRRapi.FetchRetry(exchange,pair,"1m",RetryLimit)
        close=round(ohlcv[4],8)

# Reset the cycle if either Counter is 0 or bal is less than minimum.

        if not paper:
            if bal<Trade['BuyAmount']:
                if Trade['PCTValue']==0:
                    Trade['PCTValue']=round(close*pct,8)
                Trade['Counter']=0
                WriteFutureLog(exchangeName,account,pair,direction,f"{pair:10} Balance ({bal:.8f}) < Amount ({Trade['BuyAmount']:.8f}), Resetting grid")

        # Rotate the key

        CurrentKey=((CurrentKey+1)%len(keys))
        Active=keys[CurrentKey]
        JRRapi.SetExchangeAPI(exchange,Active)

        # The rational behind this is that as the price
        # drops, so does the percentage require to make each
        # boundary. In shorting, this will mean excessive
        # purchases. The only real way to counter this is to
        # forwce the buying percentage to be based upon the 
        # all time high, just as the long PCT is at grid reset.
        # The ATH is then used at 4 time the percentage boundary
        # to ensure that runaway markets (DASH) don't destroy
        # the portfolio.

        if direction=='short':
            if close>AllTimeHigh:
                AllTimeHigh=close

        if Trade['Counter']==0 and CheckHighLow(close,Config['BuyStopLow'],Config['BuyStopHigh']):
            if not first and once:
                JRRlog.SuccessLog("Equilibrium","One cycle completed")

            if Config['ExitProfit']>0:
                if Trade['Profit']>=Config['ExitProfit']:
                    JRRlog.SuccessLog("Equilibrium","Exit profit achieved")

            if not first:
                CheckStopTracer(exchangeName,account,pair)

            # First purchase sets the direction. MUST be in the direction
            # specified on the command line or in the confguration file.

            # the first position must be opened up in the direction of
            # the trade itself even though it is the opposite of the
            # functionality of the API. FTX in particular using this 
            # to lock the direction of the trade.

            if not paper:
                Trade=TradeBuyAmount(Config,Trade,exchange,pair,pct,RetryLimit)

                res=SendWebhook(Active,exchangeName,marketType,account,orderType,pair,BuyDir,Trade['BuyAmount'],close)
                if res.find('Order Confirmation ID')>-1:
                    OrderID=GetOrderID(res)
                    if Trade['PCTValue']==0:
                        Trade['PCTValue']=round(close*pct,8)

                    Trade['Close']=round(close,8)

                    if direction=='short':
                        Trade['Buy']= round(Trade['Close']-(AllTimeHigh*(pct*4)),8)
                    else:
                        Trade['Buy']= round(Trade['Close']-Trade['PCTValue'],8)
                    Trade['Sell']=round(Trade['Close']+Trade['PCTValue'],8)
                    Trade['Counter']+=1

                    bal=JRRapi.GetContract(exchange,pair,RetryLimit)

                    vbuy='Buy/'+direction.capitalize()
                    WriteFutureLog(exchangeName,account,pair,direction,f"{pair:10} {vbuy:10} {Trade['Counter']:2.0f} {Trade['Buy']:.8f} {Trade['Close']:.8f} {Trade['Sell']:.8f} {OrderID} {bal:.8f}")

                    WriteGrid(exchangeName,account,Trade,pair)
                else:
                    JRRlog.ErrorLog("Equilibrium","Order failed")
            else:
                Trade['PCTValue']=round(close*pct,8)
                Trade['Close']=round(close,8)
                if direction=='short':
                    Trade['Buy']= round(Trade['Close']-(AllTimeHigh*(pct*4)),8)
                else:
                    Trade['Buy']= round(Trade['Close']-Trade['PCTValue'],8)
                Trade['Sell']=round(Trade['Close']+Trade['PCTValue'],8)
                Trade['Counter']+=1

                vbuy='Buy/'+direction.capitalize()
                WriteFutureLog(exchangeName,account,pair,direction,f"{pair:10} {vbuy:10} {Trade['Counter']:2.0f} {Trade['Buy']:.8f} {Trade['Close']:.8f} {Trade['Sell']:.8f}")
                WriteGrid(exchangeName,account,Trade,pair)

# Make a purchase.

        if direction=='long':
            IsBuy=close<Trade['Buy']
            cv=Trade['Buy']
        else:
            IsBuy=close>Trade['Sell']
            cv=Trade['Sell']

        if IsBuy and CheckHighLow(close,Config['BuyStopLow'],Config['BuyStopHigh']):
            if not paper:
                res=SendWebhook(Active,exchangeName,marketType,account,orderType,pair,BuyDir,Trade['BuyAmount'],cv)
                if res.find('Order Confirmation ID')>-1:
                    OrderID=GetOrderID(res)
                    if direction=='long':
                        Trade['Close']=round(Trade['Buy'],8)
                    else:
                        Trade['Close']=round(Trade['Sell'],8)
                    if direction=='short':
                        Trade['Buy']= round(Trade['Close']-(AllTimeHigh*(pct*4)),8)
                    else:
                        Trade['Buy']= round(Trade['Close']-Trade['PCTValue'],8)
                    Trade['Sell']=round(Trade['Close']+Trade['PCTValue'],8)
                    Trade['Counter']+=1

                    bal=JRRapi.GetContract(exchange,pair,RetryLimit)

                    vbuy='Buy/'+BuyDir.capitalize()
                    WriteFutureLog(exchangeName,account,pair,direction,f"{pair:10} {vbuy:10} {Trade['Counter']:2.0f} {Trade['Buy']:.8f} {Trade['Close']:.8f} {Trade['Sell']:.8f} {OrderID} {bal:.8f}")

                    WriteGrid(exchangeName,account,Trade,pair)
                else:
                    JRRlog.ErrorLog("Equilibrium","Order failed")
            else:
                if direction=='long':
                    Trade['Close']=round(Trade['Buy'],8)
                else:
                    Trade['Close']=round(Trade['Sell'],8)
                if direction=='short':
                    Trade['Buy']= round(Trade['Close']-(AllTimeHigh*(pct*4)),8)
                else:
                    Trade['Buy']= round(Trade['Close']-Trade['PCTValue'],8)
                Trade['Sell']=round(Trade['Close']+Trade['PCTValue'],8)
                Trade['Counter']+=1

                vbuy='Buy/'+BuyDir.capitalize()
                WriteFutureLog(exchangeName,account,pair,direction,f"{pair:10} {vbuy:10} {Trade['Counter']:2.0f} {Trade['Buy']:.8f} {Trade['Close']:.8f} {Trade['Sell']:.8f}")
                WriteGrid(exchangeName,account,Trade,pair)

# Make a sell only if balance > minimum

        if direction=='long':
            IsSell=close>Trade['Sell']
            cv=Trade['Sell']
        else:
            IsSell=close<Trade['Buy']
            cv=Trade['Buy']

        if Trade['Counter']>0 and IsSell  and CheckHighLow(close,Config['SellStopLow'],Config['SellStopHigh']):
            if not paper:
                Trade=TradeSellAmount(Config,Trade,exchange,pair,pct,RetryLimit)
                SellAMT=Trade['SellAmount']
                if SellAMT>bal:
                    SellAMT=bal
                res=SendWebhook(Active,exchangeName,marketType,account,orderType,pair,SellDir,SellAMT,cv)
                if res.find('Order Confirmation ID')>-1:
                    OrderID=GetOrderID(res)
                    Trade['Profit']+=round((close-Trade['Close'])*SellAMT,8)
                    if direction=='long':
                        Trade['Close']=round(Trade['Sell'],8)
                    else:
                        Trade['Close']=round(Trade['Buy'],8)
                    if direction=='short':
                        Trade['Buy']= round(Trade['Close']-(AllTimeHigh*(pct*4)),8)
                    else:
                        Trade['Buy']= round(Trade['Close']-Trade['PCTValue'],8)
                    Trade['Sell']=round(Trade['Close']+Trade['PCTValue'],8)
                    Trade['Counter']-=1

                    bal=JRRapi.GetContract(exchange,pair,RetryLimit)

                    vsell='Sell/'+SellDir.capitalize()
                    if Trade['Counter']>0:
                        WriteFutureLog(exchangeName,account,pair,direction,f"{pair:10} {vsell:10} {Trade['Counter']:2.0f} {Trade['Buy']:.8f} {Trade['Close']:.8f} {Trade['Sell']:.8f} {OrderID} {bal:.8f}")
                    else:
                        WriteFutureLog(exchangeName,account,pair,direction,f"{pair:10} {vsell:10} {Trade['Counter']:2.0f} {OrderID} {bal:.8f}")
                    WriteGrid(exchangeName,account,Trade,pair)
                else:
                    JRRlog.ErrorLog("Equilibrium","Order failed")
            else:
                Trade['Profit']+=round((close-Trade['Close'])*SellAMT,8)
                if direction=='long':
                    Trade['Close']=round(Trade['Sell'],8)
                else:
                    Trade['Close']=round(Trade['Buy'],8)
                if direction=='short':
                    Trade['Buy']= round(Trade['Close']-(AllTimeHigh*(pct*4)),8)
                else:
                    Trade['Buy']= round(Trade['Close']-Trade['PCTValue'],8)
                Trade['Sell']=round(Trade['Close']+Trade['PCTValue'],8)
                Trade['Counter']-=1

                vsell='Sell/'+SellDir.capitalize()
                if Trade['Counter']>0:
                    WriteFutureLog(exchangeName,account,pair,direction,f"{pair:10} {vsell:10} {Trade['Counter']:2.0f} {Trade['Buy']:.8f} {Trade['Close']:.8f} {Trade['Sell']:.8f}")
                else:
                    WriteFutureLog(exchangeName,account,pair,direction,f"{pair:10} {vsell:10} {Trade['Counter']:2.0f}")
                WriteGrid(exchangeName,account,Trade,pair)

        first=True
        JRRsupport.ElasticSleep(1)

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("Terminated")

