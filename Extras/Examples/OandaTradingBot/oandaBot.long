#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Jackrabbit Relay
# 2021 Copyright Â© Robert APM Darin
# All rights reserved unconditionally.

# Forex sessions:
#
# Sydney    22:00 to 07:00    AUD NZD
# Tokyo     00:00 to 09:00    JPY AUD NZD
# London    08:00 to 16:00    GBP EUR CHF
# New York  13:00 to 20:00    USD CAD XAU

# OANDA example unbounded grid bot.

# This is a very simple LONG grid bot using unbounded grids. 

# For demonstration purposes only.

import sys
sys.path.append('/home/JackrabbitRelay2/Base/Library')
import os
import json

import JackrabbitRelay as JRR
import JRRsupport

LotStart=1
LotStep=1

# We don't want any order "over-stacked" so we verify that an order isn't within range
# of anothwer order. Its a lazy way of creating an "unbounded" grid.

def AlreadyBought(relay,asset,price,pipStep):
    ot=relay.GetOpenTrades(symbol=asset)
    for o in ot:
        rp=round(price,5)
        bp=round(float(o['price']),5)
        if rp>=(bp-pipStep) and rp<=(bp+pipStep):
            return True
    return False

# Find the lowest lot size used in the list of open trades. This is a good way to make
# the entire process dynamic and fluid as lot size can be varied by any metric,
# including but not limited to, the amount of margin used.

def LowestLotSize(relay,asset):
    ot=relay.GetOpenTrades(symbol=asset)
    ls=LotStart
    done=False
    while not done:
        found=False
        for o in ot:
            iu=int(o['currentUnits'])
            if iu==ls:
                ls+=LotStep
                found=True
                break
        if not found:
            return ls
    return ls+LotStep

def HighestLotSize(relay,asset):
    ot=relay.GetOpenTrades(symbol=asset)
    ls=LotStart
    done=False
    while not done:
        found=False
        for o in ot:
            iu=abs(int(o['currentUnits']))
            if ls<iu:
                ls+=LotStep
                found=True
                break
        if not found:
            return ls+LotStep
    return ls+LotStep

# Send the order to Relay

def SendOrder(relay,**kwargs):
    Order={}
    Order['Identity']=relay.Identity['Identity']
    Order['Exchange']=relay.GetExchange()
    Order['Account']=relay.GetAccount()
    Order['Asset']=relay.GetAsset()
    Order['OrderType']="market"

    Order['Action']=kwargs.get('Action')
    if 'Units' in kwargs:
        Order['Units']=str(kwargs.get('Units'))
    if 'Ticket' in kwargs:
        Order['Ticket']=kwargs.get('Ticket')

    result=relay.SendWebhook(Order)
    return result

###
### Main code base.
###

relay=JRR.JackrabbitRelay()
if relay.GetArgsLen()>3:
    exchangeName=relay.GetExchange()
    account=relay.GetAccount()
    asset=relay.GetAsset()
else:
    print("An exchange, (sub)account, and an asset must be provided.")
    sys.exit(1)

MarginLimit=-1
if relay.GetArgsLen()>4:
    MarginLimit=float(sys.argv[4])

# The range of actual profit and distance from other orders. spread is added
# automatically.

pipStep=0.0005

# Make first purchase if none already available

ticker=relay.GetTicker(symbol=asset)
ot=relay.GetOpenTrades(symbol=asset)
if len(ot)==0:
    lotSize=LotStart
    buy=ticker['Bid']
    relay.JRLog.Write(f"Long - Buy @{buy:7.5f} -> {lotSize}")
    result=relay.PlaceOrder(pair=asset,orderType="market",action="buy",amount=lotSize,price=buy)
else:
    lotSize=LowestLotSize(relay,asset)

while True:
    # Get balance
    balance=relay.GetBalance()
    # Get the margin used
    marginUsed=0
    positions=relay.GetPositions()
    if positions!=None:
        for pos in positions:
            srch=pos['instrument'].replace('_','/')
            if srch==asset:
                marginUsed=round(float(pos['marginUsed']),5)
                break
    marginPips=marginUsed*0.0001

    # Get th ticker
    ticker=relay.GetTicker(symbol=asset)

    # Get the highest lot size
    unitPips=HighestLotSize(relay,asset)*0.0001

    lowestPrice=999999
    ot=relay.GetOpenTrades(symbol=asset)
    for o in ot:
        id=o['id']
        iu=int(o['currentUnits'])
        price=float(o['price'])

        if price<(lowestPrice-pipStep-ticker['Spread']):
            lowestPrice=price;
        print(f"{id} {iu}/{price:7.5f} -> {(price+pipStep+ticker['Spread']):7.5f}")

        # CLOSE any position over profit level

        sellPrice=(price+pipStep+ticker['Spread'])
        if iu>0 and ticker['Bid']>=sellPrice:
            relay.JRLog.Write(f"{id} Long - Sell @{sellPrice:7.5f} -> {iu}/{balance:12.5f}")

            result=SendOrder(relay,Action="Close",Ticket=id)

            # Replaceent order

            if not AlreadyBought(relay,asset,ticker['Bid'],pipStep+marginPips+unitPips+ticker['Spread']):
                if MarginLimit<0 or (MarinLimit>0 and marginUsed<MarginLimit):
                    lotSize=LowestLotSize(relay,asset)
                    details=relay.GetOrderDetails(OrderID=id)[-1]
                    price=float(details['price'])
                    relay.JRLog.Write(f"Long - Replacement Buy @{price:7.5f} -> {lotSize}")
                    result=SendOrder(relay,Action="buy",Units=lotSize)

    # Next buy price minus pip step

    buy=round(lowestPrice-pipStep-marginPips-unitPips-ticker['Spread'],5)
    print(f"Buy -> {buy:7.5f}/{ticker['Bid']:7.5f} Margin: {marginUsed:8.5f}")
    lotSize=LowestLotSize(relay,asset)

    if ticker['Bid']<buy:
        if not AlreadyBought(relay,asset,ticker['Bid'],pipStep+marginPips+unitPips+ticker['Spread']):
            if MarginLimit<0 or (MarginLimit>0 and marginUsed<MarginLimit):
                # Long buy
                relay.JRLog.Write(f"Long - Buy @{buy:7.5f} -> {lotSize}")
                result=SendOrder(relay,Action="buy",Units=lotSize)

    print(f"LotSize -> {lotSize}\n")

    op=ticker['Bid']
    JRRsupport.ElasticSleep(1)
