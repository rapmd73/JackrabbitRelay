#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Jackrabbit Relay
# 2021 Copyright Â© Robert APM Darin
# All rights reserved unconditionally.

# Forex sessions:
#
# Sydney    22:00 to 07:00    AUD NZD
# Tokyo     00:00 to 09:00    JPY AUD NZD
# London    08:00 to 16:00    GBP EUR CHF
# New York  13:00 to 20:00    USD CAD XAU
#

import sys
sys.path.append('/home/GitHub/JackrabbitRelay/Base/Library')
import os
import json

import JackrabbitRelay as JRR
import JRRsupport

def AlreadyBought(relay,asset,price,pipStep):
    ot=relay.GetOpenTrades(symbol=asset)
    for o in ot:
        rp=round(price,5)
        bp=round(float(o['price']),5)
        if rp>=(bp-pipStep) and rp<=(bp+pipStep):
            return True
    return False

def LowestLotSize(relay,asset):
    ot=relay.GetOpenTrades(symbol=asset)
    ls=1
    done=False
    while not done:
        found=False
        for o in ot:
            iu=int(o['currentUnits'])
            if iu==ls:
                ls+=1
                found=True
                break
        if not found:
            return ls
    return ls+1

###
### Main code base. Place order on exchange
###

relay=JRR.JackrabbitRelay()
if relay.GetArgsLen() > 3:
    exchangeName=relay.GetExchange()
    account=relay.GetAccount()
    asset=relay.GetAsset()
else:
    print("An exchange, (sub)account, and an asset must be provided.")
    sys.exit(1)

count=3650

# 30 pips = ~0.3%

pipStep=0.0005

markets=relay.Markets

ticker=relay.GetTicker(symbol=asset)
op=ticker['Bid']

ot=relay.GetOpenTrades(symbol=asset)
if len(ot)==0:
    lotSize=1
    result=relay.PlaceOrder(pair=asset,orderType="market",action="buy",amount=lotSize,price=ticker['Bid'])
    buyPrice=float(result['orderFillTransaction']['price'])
    print(f"** Long - Buy {lotSize} @{buyPrice:7.5f}")
else:
    lotSize=LowestLotSize(relay,asset)

while True:
    ticker=relay.GetTicker(symbol=asset)
    pips=round((ticker['Bid']-op)*10000,5)

    lowestPrice=999999
    ot=relay.GetOpenTrades(symbol=asset)
    for o in ot:
        id=o['id']
        iu=int(o['currentUnits'])
        price=float(o['price'])

        if price<(lowestPrice-pipStep-ticker['Spread']):
            lowestPrice=price;
        print(f"{id} {iu}/{price:7.5f} -> {(price+pipStep+ticker['Spread']):7.5f}")

        # CLOSE any position over profit level
        # Short
        # if (iu<0 and ticker['Bid']<price-pipStep):

        sellPrice=(price+pipStep+ticker['Spread'])
        if iu>0 and ticker['Bid']>=sellPrice:
            relay.JRLog.Write(f"{id} Long - Sell {iu} @{sellPrice:7.5f}")
            result=relay.PlaceOrder(pair=asset,orderType="market",action="sell",amount='ALL',ticket=id,price=price)
            # Reset NEXT order size as price climbs
            #if iu==1:
            #    print(f"** RESET @{price:7.5f}")
            #    lotSize=2
            # Replaceent order
            if not AlreadyBought(relay,asset,price,pipStep):
                lotSize=LowestLotSize(relay,asset)
                price=float(result['orderFillTransaction']['price'])
                relay.JRLog.Write(f"Long - Buy @{price:7.5f} -> {lotSize}")
                result=relay.PlaceOrder(pair=asset,orderType="market",action="buy",amount=lotSize,price=price)

    # Next buy price minus pip step

    buy=lowestPrice-pipStep-ticker['Spread']
    print(f"Buy -> {buy:7.5f}/{ticker['Bid']:7.5f}")

    if ticker['Bid']<buy:
        if not AlreadyBought(relay,asset,buy,pipStep) \
        and not AlreadyBought(relay,asset,ticker['Bid']+ticker['Spread'],pipStep):
            # Long buy
            lotSize=LowestLotSize(relay,asset)
            relay.JRLog.Write(f"Long - Buy @{buy:7.5f} -> {lotSize}")
            result=relay.PlaceOrder(pair=asset,orderType="market",action="buy",amount=lotSize,price=buy)

    print(f"LotSize -> {lotSize}\n")

    op=ticker['Bid']
    JRRsupport.ElasticSleep(1)
