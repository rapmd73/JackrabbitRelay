#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Jackrabbit OliverTwist
# 2021 Copyright Â© Robert APM Darin
# All rights reserved unconditionally.

# This is the Jackrabbit limit order manager. Its purpose is to track and maintain "orphaned" orders. Orphan orders are liit
# order that the parent or order initiator does not wat a response for. TradingView is an example, but the situation applies
# to any process that does not manage or maintain limit orders on their own.

# IMPORTANT: Under no circumstances should THIS program manage an individual order. It is to be managed by a separate process,
# called an orphan manager. This is simply because there is no way on knowing how many exchanges/brokers might be used
# simultaneously. The memory of a single process managing a thousand orders would be absolutely thrashed. The orphan manager
# will follow the same conventions of the PlaceOrder program, ie:

#    Orphan.ccxt
#    Orphan.oanda
#    Conditional.ccxt
#    Conditional.oanda

# ANY order (direct orphan or conditional) is an ORPHAN at all times withis THIS framework.

# IMPORTANT: This fraework treats conditionals the same as orphans. The separation and distinction takes place in the
# transactor. While this has plenty of issues to be aware of, it is the most effecient way of handling the situation since at
# this level (dispatcher), they are syntactically the same.

# Framework identification, along with any other order verification, is done in the PlaceOrder

import sys
sys.path.append('/home/JackrabbitRelay2/Base/Library')
import os
import time
import json
import random
import subprocess

import JRRsupport
import JackrabbitRelay as JRR

Version="0.0.0.1.505"
BaseDirectory='/home/JackrabbitRelay2/Base'
DataDirectory='/home/JackrabbitRelay2/Data'
ConfigDirectory='/home/JackrabbitRelay2/Config'
LogDirectory="/home/JackrabbitRelay2/Logs"

ConditionalReceiver=DataDirectory+'/OliverTwist.Conditional.Receiver'
OrphanReceiver=DataDirectory+'/OliverTwist.Orphan.Receiver'

ConditionalStorehouse=DataDirectory+'/OliverTwist.Conditional.Storehouse'
OrphanStorehouse=DataDirectory+'/OliverTwist.Orphans.Storehouse'

NumberProcesses=os.cpu_count()

# Set up the logging system

JRLog=JRR.JackrabbitLog()

# Set up signal interceptor

interceptor=JRRsupport.SignalInterceptor(Log=JRLog)

# The timeout setting for the memory locks. If it takes longer then 15 minutes to
# check the status of an order, there is a major problem with the exchange/broker.
# Testing has show that only a few seconds is actually requred. The extended amount
# is just to compensate for an overloaded server.

OliverTwistTimeout=(15*60)

# This lock guards the lists. Both PlaceOrder.olivertwist and
# JackrabbitOliverTwist will access this file. Collisions must not be allowed to
# happen.

OliverTwistLock=JRRsupport.Locker("OliverTwist")

# Compare orphan IDs

def compareListKey(node,dz):
    nData=node.GetData()

    d2=json.loads(nData)['Key']
    d1=json.loads(dz)['Key']

    if d1<d2:
        r=-1
    elif d1>d2:
        r=1
    else:
        r=0

    return r

# The list of orphaned orders to track and manage. Must be global, but after
# compare function declared.

OrphanList=JRRsupport.DList(Compare=compareListKey)
OrphanMemory={}
OrphanListChanged=False

# The list of conditional orders to track and manage. Must be global, but after
# compare function declared.

ConditionalList=JRRsupport.DList(Compare=compareListKey)
ConditionalMemory={}
ConditionalListChanged=False

# We only want to write to disk when there is an actual change in the OrphanList

# Generate a random ID

def GetID():
    letters="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    llen=len(letters)

    pw=""
    oc=""

    for i in range(20):
        done=False
        while not done:
            for z in range(random.randrange(73,237)):
                c=random.randrange(llen)
            if pw=="" or (len(pw)>0 and letters[c]!=oc):
                done=True
        oc=letters[c]
        pw+=oc
    return pw

# Read the complete list stored on disk, if it exists. Supports both orphans and conditionals.

def ReadOrphanList(cl=None):
    # Required as the blobals are modified
    global OliverTwistLock
    global OrphanList
    global OrphanMemory
    global OrphanListChanged
    global ConditionalList
    global ConditionalMemory
    global ConditionalListChanged
    global JRLog

    if cl==None:
        JRLog.Error("Storehouse","Storehouse not provided")

    # Setup mechanism to switch between orphan and conditional storehouses
    if cl=='Orphan':
        WorkingStorehouse=OrphanStorehouse
    else:
        WorkingStorehouse=ConditionalStorehouse

    while OliverTwistLock.Lock()!='locked':
        JRRsupport.ElasticSleep(1)

    if os.path.exists(WorkingStorehouse):
        buffer=JRRsupport.ReadFile(WorkingStorehouse)
        if buffer!=None and buffer!='':
            Orphans=buffer.split('\n')
            for Entry in Orphans:
                # Force set InMotion to False
                Entry=Entry.strip()
                if Entry=='':
                    continue
                # Break down entry and set up memory locker
                try:
                    Orphan=json.loads(Entry)
                except:
#                    JRLog.Write(f"Bad orphan: {Entry}")
                    continue

                if 'Order' in Orphan:
                    if type(Orphan['Order'])==str:
                        order=json.loads(Orphan['Order'])
                        order.pop('Identity',None)
                        Orphan['Order']=order
                if 'Response' in Orphan:
                    if type(Orphan['Response'])==str:
                        resp=json.loads(Orphan['Response'])
                        Orphan['Response']=resp

                if cl=='Orphan':
                    Orphan['Class']='Orphan'
                    OrphanList.insert(json.dumps(Orphan))

                    OrphanMemory[Orphan['Key']]=JRRsupport.Locker(Orphan['Key'])
                    OrphanMemory[Orphan['Key']].Put(OliverTwistTimeout*100,"Waiting")

                    OrphanListChanged=True
                elif cl=='Conditional':
                    Orphan['Class']='Conditional'
                    ConditionalList.insert(json.dumps(Orphan))

                    ConditionalMemory[Orphan['Key']]=JRRsupport.Locker(Orphan['Key'])
                    ConditionalMemory[Orphan['Key']].Put(OliverTwistTimeout*100,"Waiting")

                    ConditionalListChanged=True

            if cl=='Orphan':
                JRLog.Write(f"{OrphanList.size} {cl.lower()}(s) read")
            else:
                JRLog.Write(f"{ConditionalList.size} {cl.lower()}(s) read")
    OliverTwistLock.Unlock()

# Write only when there are changes.

def WriteOrphanList(cl):
    global OliverTwistLock
    global OrphanList
    global ConditionalList

    interceptor.Critical(True)
    OliverTwistLock.Lock()
    buffer=''
    if cl=='Orphan':
        cur=OrphanList.GetHead()
    else:
        cur=ConditionalList.GetHead()
    while cur!=None:
        buffer+=cur.GetData()+'\n'
        cur=cur.GetNext()

    if cl=='Orphan':
        WorkingStorehouse=OrphanStorehouse
    else:
        WorkingStorehouse=ConditionalStorehouse

    JRRsupport.WriteFile(WorkingStorehouse,buffer)
    OliverTwistLock.Unlock()
    interceptor.Critical(False)

    # Process any signals received during critical section
    interceptor.SafeExit()

# Check the receiver file for new orders.

def ReceiveOrphans(cl):
    # Required as the blobals are modified
    global OliverTwistLock
    global OrphanList
    global OrphanMemory
    global OrphanListChanged
    global ConditionalList
    global ConditionalMemory
    global ConditionalListChanged
    global JRLog

    if cl==None:
        JRLog.Error("Receiver","Storehouse not provided")

    # The key is the time of payload and random ID

    if cl=='Orphan':
        WorkingReceiver=OrphanReceiver
    else:
        WorkingReceiver=ConditionalReceiver

    OliverTwistLock.Lock()
    if os.path.exists(WorkingReceiver):
        buffer=JRRsupport.ReadFile(WorkingReceiver)
        if buffer!=None and buffer!='':
            # Remove the receiver after we load it
            os.remove(WorkingReceiver)

            # Process all the orphans

            rc=0
            Orphans=buffer.split('\n')
            for Entry in Orphans:
                if Entry.strip()=='':
                    continue

                try:
                    Orphan=json.loads(Entry)
                except:
                    JRLog.Write(f"Broken: {Entry}")
                    continue

                if 'Order' in Orphan:
                    if type(Orphan['Order'])==str:
                        order=json.loads(Orphan['Order'])
                        order.pop('Identity',None)
                        Orphan['Order']=order
                if 'Response' in Orphan:
                    if type(Orphan['Response'])==str:
                        resp=json.loads(Orphan['Response'])
                        Orphan['Response']=resp

                Orphan['Key']=Orphan['DateTime']+'.'+GetID()

                if cl=='Orphan':
                    Orphan['Class']='Orphan'
                    OrphanList.insert(json.dumps(Orphan))

                    OrphanMemory[Orphan['Key']]=JRRsupport.Locker(Orphan['Key'])
                    OrphanMemory[Orphan['Key']].Put(OliverTwistTimeout*100,"Waiting")
                    OrphanListChanged=True
                else:
                    Orphan['Class']='Conditional'
                    ConditionalList.insert(json.dumps(Orphan))

                    ConditionalMemory[Orphan['Key']]=JRRsupport.Locker(Orphan['Key'])
                    ConditionalMemory[Orphan['Key']].Put(OliverTwistTimeout*100,"Waiting")
                    ConditionalListChanged=True

                rc+=1
            if rc>0:
                JRLog.Write(f"{rc} {cl.lower()}n(s) received")
    OliverTwistLock.Unlock()

# This spins up the orphan manager to ensure each orphan is handled. This is NOT part of the main process, but rather a child
# process. NONE o the global or main variables are available. The ONLY information know is what is EXPLICTLY given.

# An Orphan transactor will process orphans. A relatively easy process compared to the Conditional transactor. The Condiional
# transactor will need to back feed orders into Relay, usingsimilat techniques compared to the PlaceOrder system. The
# Conditional framework will be a logistical nightmare. Emphasis has to be on speed in processing the conditions.

def ProcessOrphan(**kwargs):
    global JRLog

    # The entire kwargs payload is the orphan JSON...
    Orphan=kwargs

    # Figure out which transactor is needed
    if Orphan['Class']=='Orphan':
        OrphanManager=BaseDirectory+'/Orphan.'+Orphan['Framework']
    else:
        OrphanManager=BaseDirectory+'/Conditional.'+Orphan['Framework']

    # Diagnostics only
    # fn=f"/tmp/{Orphan['Framework']},{Orphan['Key']}.OliverTwist"
    # if not os.path.exists(fn):
    #     JRRsupport.WriteFile(fn,json.dumps(Orphan)+'\n')

    if os.path.exists(OrphanManager):
        transactor=[ OrphanManager ]

        # Time to get down to business

        try:
            payload=json.dumps(Orphan).encode()
            #JRRsupport.AppendFile("/home/trap.txt",json.dumps(Orphan)+"\n")

            subp=subprocess.Popen(transactor,stdin=subprocess.PIPE,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
            subp.stdin.write(payload)
            subp.communicate() # [0].decode().strip()

            # response will be in Jackrabbit Locker as a memory element
            return None
        except Exception as e:
            # This should never happen, but if it dowes, go back to waiting state. Class doesn't matter here
            Memory=JRRsupport.Locker(Orphan['Key'],ID=Orphan['mID'])
            Memory.Put(OliverTwistTimeout*100,"Waiting")
            return None

    # This should never happen, but if it dowes, go back to waiting state. Class doesn't matter here
    Memory=JRRsupport.Locker(Orphan['Key'],ID=Orphan['mID'])
    Memory.Put(OliverTwistTimeout*100,"Waiting")
    return None

# Process each child. Handles both orphans and conditionals
#
# memData will be eithewr OrphanMemory or ConfitionalMemory

def ProcessChild(CurList,cur,memData,CurListChanged):
    data=json.loads(cur.GetData())

    # Get result from Locker

    OliverTwistLock.Lock()
    sData=json.loads(memData[data['Key']].Get())
    OliverTwistLock.Unlock()

    if 'DataStore' in sData:
        status=sData['DataStore'].lower()
    else:
        status=sData['Status'].lower()

    # This check must contain all possible expected values.

    if status!='delete' and status!='running':
        if status=='done' \
        or status=='notfound' \
        or status=='notowner' \
        or status=='waiting':
            status='waiting'
        else:
            JRLog.Error("Corruption",f"{data['Key']}: {sData}")

    if status=='delete':
        # This is the ONLY way to properly handle deletions that
        # won't risk trashing memory, as this part of the program is
        # huarenteed to be non-parrellel. The next pointer must be
        # fetched BEFORE this orphan is removed to maintain the list
        # scan integrity.

        OliverTwistLock.Lock()
        # Get next orphan
        cNext=cur.GetNext()
        # Remove THIS orphan
        memData[data['Key']].Erase()
        memData.pop(data['Key'],None)
        CurList.delete(cur.GetData())
        # Set the next orphan
        cur=cNext
        CurListChanged=True
        OliverTwistLock.Unlock()

        JRLog.Write(f"Processed {data['Class'].lower()}: {data['Key']}")
    else:
        OliverTwistLock.Lock()

        # Only run if not already running. It is possible for this state to
        # occur, especially if there are only a few orders to process or a
        # very fast broker.

        # ID *MUST* be dynamic for security. Howver, the child process has
        # to have it in order to access the data store. orphan lock and
        # orphan memory IDs will be different.

        if status=='waiting':
            data['lID']=OliverTwistLock.ID
            data['mID']=memData[data['Key']].ID
            memData[data['Key']].Put(OliverTwistTimeout*100,"Running")
            interceptor.StartProcess(ProcessOrphan,kwargs=data)

        cur=cur.GetNext()
        OliverTwistLock.Unlock()

        # Process any signals received during critical section
        interceptor.SafeExit()

    # Return the updated list information

    return CurList,cur,CurListChanged

###
### Main driver
###

def main():
    global NumberProcesses
    global OliverTwistLock
    global OrphanList
    global OrphanMemory
    global OrphanListChanged
    global ConditionalList
    global ConditionalMemory
    global ConditionalListChanged
    global JRLog

    JRLog.Write('OliverTwist '+Version)

    if len(sys.argv)>1:
        NumberProcesses=int(sys.argv[1])
    JRLog.Write(f'Spawning {NumberProcesses} sub-processes')

    # Load saved orphans into memory
    ReadOrphanList('Orphan')
    ReadOrphanList('Conditional')

    # Outter loop, cycles orphans

    cur=None
    while True:
        # Inner loop cycles conditional orders for every single orphan

        ReceiveOrphans('Conditional')
        cor=ConditionalList.GetHead()
        while cor!=None:
            ConditionalList,cor,ConditionalListChanged=ProcessChild(ConditionalList,cor,ConditionalMemory,ConditionalListChanged)

            # Update Conditional storehouse, if needed
            if ConditionalListChanged==True:
                OliverTwistLock.Lock()
                WriteOrphanList('Conditional')
                ConditionalListChanged=False
                OliverTwistLock.Unlock()

            # Process any signals received during critical section
            interceptor.SafeExit()

            # Only allow "NumberProcesses" children to run as once.

            while interceptor.GetChildren()>(NumberProcesses-1):
                JRRsupport.ElasticSleep(1)

        # Check for new orphans
        ReceiveOrphans('Orphan')

        # Walk the list of orphans one by one.
        if cur==None:
           cur=OrphanList.GetHead()

        # Make sure we actuallyhave orphans to process

        if cur!=None:
            OrphanList,cur,OrphanListChanged=ProcessChild(OrphanList,cur,OrphanMemory,OrphanListChanged)

            # Save the orphan list to disk, ONLY IF it actually changed

            if OrphanListChanged==True:
                OliverTwistLock.Lock()
                WriteOrphanList('Orphan')
                OrphanListChanged=False
                OliverTwistLock.Unlock()

        # Only allow "NumberProcesses" children to run as once.

        while interceptor.GetChildren()>(NumberProcesses-1):
            JRRsupport.ElasticSleep(1)

        # Process any signals received during critical section
        interceptor.SafeExit()

        # Brief rest to maintain control over server
        JRRsupport.ElasticSleep(1)

if __name__ == '__main__':
    main()
