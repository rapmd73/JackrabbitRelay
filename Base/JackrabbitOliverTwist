#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Jackrabbit OliverTwist
# 2021 Copyright Â© Robert APM Darin
# All rights reserved unconditionally.

# This is the Jackrabbit limit order manager. Its purpose is to track and
# maintain "orphaned" orders. Orphan orders are liit order that the parent or
# order initiator does not wat a response for. TradingView is an example, but
# the situation applies to any process that does not manage or maintain limit
# orders on their own.

# IMPORTANT: Under no circumstances should THIS program manage an individual
# order. It is to be managed by a separate process, called an orphan manager.
# This is simply because there is no way on knowing how many exchanges/brokers
# might be used simultaneously. The memory of a single process managing a
# thousand orders would be absolutely thrashed. The orphan manager will follow
# the same conventions of the PlaceOrder program, ie:

#    Orphan.ccxt
#    Orphan.oanda

# Framework identification, along with any other order verification, is done in
# PlaceOrder.OliverTwist

import sys
sys.path.append('/home/JackrabbitRelay2/Base/Library')
import os
import time
import json
import random
import multiprocessing
import subprocess

import JRRsupport

Version="0.0.0.1.0"
BaseDirectory='/home/JackrabbitRelay2/Base'
DataDirectory='/home/JackrabbitRelay2/Data'
ConfigDirectory='/home/JackrabbitRelay2/Config'
LogDirectory="/home/JackrabbitRelay2/Logs"

OrphanReceiver=DataDirectory+'/OliverTwist.Receiver'
OrphanStorehouse=DataDirectory+'/OliverTwist.Storehouse'

# Global lock required to prevent memory from being destroyed during asychonrous
# activity.

gLock=JRRsupport.Locker("OliverTwist")

# This lock guards the receiver file. Both PlaceOrder.olivertwist and
# JackrabbitOliverTwist will access this file. Collisions must not be allowed to
# happen.

orphanLock=JRRsupport.Locker(OrphanReceiver)

# Compare orphan IDs

def compareOrphan(node,dz):
    nData=node.GetData()

    d2=str(json.loads(nData)['Key'])
    d1=str(json.loads(dz)['Key'])

    if d1<d2:
        r=-1
    elif d1>d2:
        r=1
    else:
        r=0
    return r

# The list of orphaned orders to track and manage. Must be global, but after
# compare function declared.

OrphanList=JRRsupport.DList(Compare=compareOrphan)

# Generate a random ID

def GetID():
    letters="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    llen=len(letters)

    pw=""
    oc=""

    for i in range(20):
        done=False
        while not done:
            for z in range(random.randrange(73,237)):
                c=random.randrange(llen)
            if pw=="" or (len(pw)>0 and letters[c]!=oc):
                done=True
        oc=letters[c]
        pw+=oc
    return pw

# Receive an update on an orphan and update, delete, or add to the main list

def OrphanUpdate(result):
    # Locking required to protect memory structures

    gLock.Lock()

    # At this stage, pData should NEVER be None or undefined. If it is, then
    # memory was thrashed.

    # Find entry in list by ID
    pData=pList.find(json.dumps(result))
    if pData!=None:
        # Get original list entry
        pd=json.loads(pData.GetData())
        # Add data element to original entry
        pd['Result']=result['Result']
        # Update the original list with new data
        pData.SetData(json.dumps(pd))
    gLock.Unlock()

# This spins up the orphan manager to ensure each orphan is handled.

def ProcessOrphan(Key):
    OrphanManager=BaseDirectory+'/OrphanManager'

    transactor=[ OrphanManager ]
    subp=subprocess.Popen(transactor,stdin=subprocess.PIPE,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
    subp.stdin.write(payload.encode())
    res=subp.communicate()[0].decode().strip()

    pData={}
    pData['Key']=Key
    pData['Result']=res
    return pData

def ReadOrphanList():
    pass

# Write only when there are changes.

def WriteOrphanList():
    pass

# Check the receiver file for new orders.

# Order stattus:

#    New        Process order, buy, sell, close
#    Pending    Already placed order, waiting for completion

def ReceiveOrphans():
    # The key is the time of payload and random ID

#    orphanLock.Lock()
#    try:
    if 1==1:
        buffer=JRRsupport.ReadFile(OrphanReceiver)
        if buffer!=None and buffer!='':
            # Remove the receiver after we load it
            # os.remove(OrphanReceiver)

            # Process all the orphans

            Orphans=buffer.split('\n')
            for Entry in Orphans:
                if Entry.strip()=='':
                    continue

                Orphan=json.loads(Entry)

                Orphan['Key']=Orphan['DateTime']+'.'+GetID()

                print(json.dumps(Orphan))

                OrphanList.insert(json.dumps(Orphan))

        orphanLock.Unlock()
        sys.exit(1)
#    except:
#        orphanLock.Unlock()

###
### Main driver
###

def main():
    # Read saved list from disk into OrphanList

    # Establish the process pool to handle the orphans
#    ProcessPool=multiprocessing.Pool(processes=multiprocessing.cpu_count()*2,maxtasksperchild=237)

#    try:
    if 1==1:
        while True:

            # Walk the list of orphans.

            cur=OrphanList.GetHead()

            # If there is no list, check the receiver
            if cur==None:
                ReceiveOrphans()
                sys.exit(1)

            while cur!=None:
                ReceiveOrphans()

                if cur!=None:
                    print(cur)
                    #ProcessPool.apply_async(ProcessOrphan,args=(data,cur['Key'],),callback=OrphanUpdata)

                    cur=cur.GetNext()

            # Brief rest to maintain control over server
            JRRsupport.ElasticSleep(1)
#    except:
        # Something bad happensed. Clean up and shutdown
#        gLock.Unlock()
#        ProcessPool.close()
#        ProcessPool.join()

if __name__ == '__main__':
#    try:
        main()
#    except:
#        gLock.Unlock()

