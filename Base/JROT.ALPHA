#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Jackrabbit OliverTwist
# 2021 Copyright Â© Robert APM Darin
# All rights reserved unconditionally.

# This is the Jackrabbit limit/conditional order manager. Its purpose is to track and maintain "orphaned" orders.
# Orphan orders are limit order that the parent or order initiator does not wat a response for. TradingView is an
# example, but the situation applies to any process that does not manage or maintain limit orders on their own.

# IMPORTANT: Under no circumstances should THIS program manage an individual order. It is to be managed by a
# separate process, called an orphan manager. This is simply because there is no way on knowing how many
# exchanges/brokers might be used simultaneously. The memory of a single process managing a thousand orders would
# be absolutely thrashed. The orphan manager will follow the same conventions of the PlaceOrder program, ie:

#    Orphan.ccxt
#    Orphan.oanda
#    Conditional.ccxt
#    Conditional.oanda
#    Conditional.mimic

# ANY order (direct orphan or conditional) is an ORPHAN at all times with this THIS framework.

# IMPORTANT: This framework treats conditionals the same as orphans. The separation and distinction takes place in
# the transactor. While this has plenty of issues to be aware of, it is the most effecient way of handling the
# situation since at this level (dispatcher), they are syntactically the same.

# Framework identification, along with any other order verification, is done in the PlaceOrder

# Now we get to the crazy stuff. This program now uses multiple layers of parent/child layering as follows:

# Global/Parent -> This is the global level that tracks the various storehouses (orders for (exchange/account/asset)

# Child -> Reads the list of orders for a given storehouse. This is multiprocess.

# Grandchild -> Processes individual orders using inherieted globals from it parent (Child). Grandparent (Parent)
#               has no role here and primary locks need to be overridden with parent (Child) locks.

import sys
# Needed to find Relay libraries
sys.path.append('/home/JackrabbitRelay2/Base/Library')
import os
import importlib
import time
import json
import random

import JRRsupport
import JackrabbitRelay as JRR

Version="0.0.0.1.730"
BaseDirectory='/home/JackrabbitRelay2/Base'
DataDirectory='/home/JackrabbitRelay2/Data'
ConfigDirectory='/home/JackrabbitRelay2/Config'
LogDirectory='/home/JackrabbitRelay2/Logs'
StorageDirectory=DataDirectory+'/OliverTwist'

NumberProcesses=os.cpu_count()

# Set up the logging system

JRLog=JRR.JackrabbitLog()

# Set up signal interceptor

interceptor=JRRsupport.SignalInterceptor(Log=JRLog)

# The timeout setting for the memory locks. If it takes longer then 15 minutes to
# check the status of an order, there is a major problem with the exchange/broker.
# Testing has show that only a few seconds is actually requred. The extended amount
# is just to compensate for an overloaded server.

OliverTwistTimeout=86400

# This lock guards the lists. Both PlaceOrder.olivertwist and
# JackrabbitOliverTwist will access this file. Collisions must not be allowed to
# happen.

OrphanLock={}
StorehouseLock={}

# The list of orphaned/conditional orders to track and manage. Must be global, but after compare function
# declared.

OrphanList={}
OrphanMemory={}

StorehouseMemory={}

# Generate a random ID

def GetID():
    letters="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    llen=len(letters)

    pw=""
    oc=""

    for i in range(20):
        done=False
        while not done:
            for z in range(random.randrange(73,237)):
                c=random.randrange(llen)
            if pw=="" or (len(pw)>0 and letters[c]!=oc):
                done=True
        oc=letters[c]
        pw+=oc
    return pw

# Convert old format to new format
### TERMPORARY... Will remove in several generations.

def ConvertIndividualFile(fn):
    if os.path.exists(fn):
        buffer=JRRsupport.ReadFile(fn).strip()
        if buffer!=None and buffer!='':
            # Remove the receiver after we load it
            os.remove(fn)

            # Process all the orphans

            Orphans=buffer.split('\n')
            for Entry in Orphans:
                if Entry.strip()=='':
                    continue

                try:
                    Orphan=json.loads(Entry)
                except:
                    JRLog.Write(f"Broken: {Entry}")
                    continue

                if 'Order' in Orphan:
                    if type(Orphan['Order'])==str:
                        order=json.loads(Orphan['Order'])
                        order.pop('Identity',None)
                        Orphan['Order']=order
                if 'Response' in Orphan:
                    if type(Orphan['Response'])==str:
                        resp=json.loads(Orphan['Response'])
                        Orphan['Response']=resp

                if 'Key' not in Orphan:
                    Orphan['Key']=Orphan['DateTime'].replace(' ','.')+'.'+GetID()

                f=Orphan['Framework']
                e=Orphan['Order']['Exchange']
                a=Orphan['Order']['Account']
                nsf=f"{StorageDirectory}/{f}.{e}.{a}"
                JRRsupport.AppendFile(nsf,json.dumps(Orphan)+'\n')

def ConvertOld2New():
    if not os.path.exists(StorageDirectory):
        JRRsupport.mkdir(StorageDirectory)

        files=['OliverTwist.Conditional.Receiver','OliverTwist.Orphan.Receiver','OliverTwist.Conditional.Storehouse','OliverTwist.Orphans.Storehouse','OliverTwist.Storehouse']

        for fh in files:
            fn=DataDirectory+'/'+fh
            ConvertIndividualFile(fn)

# Check the receiver file for new orders.

def ReceiveOrphans(Storehouse,):
    # Required as the globals are modified
    global StorehouseLock
    global OrphanList
    global OrphanMemory
    global JRLog

    # The key is the time of payload and random ID

    WorkingReceiver=StorageDirectory+'/'+Storehouse+'.receiver'

    StorehouseLock[Storehouse].Lock()
    if os.path.exists(WorkingReceiver):
        buffer=JRRsupport.ReadFile(WorkingReceiver).strip()
        if buffer!=None and buffer!='':
            # Remove the receiver after we load it
            os.remove(WorkingReceiver)

            # Process all the orphans

            Orphans=buffer.split('\n')
            for Entry in Orphans:
                if Entry.strip()=='':
                    continue

                try:
                    Orphan=json.loads(Entry)
                except:
                    JRLog.Write(f"Broken: {Entry}")
                    continue

                if 'Order' in Orphan:
                    if type(Orphan['Order'])==str:
                        order=json.loads(Orphan['Order'])
                        order.pop('Identity',None)
                        Orphan['Order']=order
                if 'Response' in Orphan:
                    if type(Orphan['Response'])==str:
                        resp=json.loads(Orphan['Response'])
                        Orphan['Response']=resp

                Orphan['Key']=Orphan['DateTime'].replace(' ','.')+'.'+GetID()

                # Double check for duplicates.
                if 'Key' in Orphan and Orphan['Key'] in OrphanList:
                    continue

                OrphanLock[Orphan['Key']]=JRRsupport.Locker(f"OliverTwist.{Orphan['Key']}.orphan")
                OrphanMemory[Orphan['Key']]=JRRsupport.Locker(f"OliverTwist.{Orphan['Key']}.memory")
                OrphanMemory[Orphan['Key']].Put(OliverTwistTimeout,"Waiting")

                Orphan['lID']=OrphanLock[Orphan['Key']].ID
                Orphan['mID']=OrphanMemory[Orphan['Key']].ID

                OrphanList[Orphan['Key']]=json.dumps(Orphan)
            WriteOrphanList(Storehouse)
    StorehouseLock[Storehouse].Unlock()

# Read the complete list stored on disk, if it exists. Supports both orphans and conditionals.

def ReadOrphanList(Storehouse):
    # Required as the globals are modified
    global StorehouseLock
    global OrphanList
    global OrphanMemory
    global JRLog

    WorkingStorehouse=StorageDirectory+'/'+Storehouse

    # Wait until we have the lock
    while StorehouseLock[Storehouse].Lock()!='locked':
        JRRsupport.ElasticSleep(1)

    if os.path.exists(WorkingStorehouse):
        buffer=JRRsupport.ReadFile(WorkingStorehouse).strip()
        if buffer!=None and buffer!='':
            Orphans=buffer.split('\n')
            for Entry in Orphans:
                # Force set InMotion to False
                Entry=Entry.strip()
                if Entry=='':
                    continue

                # Break down entry and set up memory locker
                try:
                    Orphan=json.loads(Entry)
                except:
#                    JRLog.Write(f"Bad orphan: {Entry}")
                    continue

                # Double check for duplicates.
                if 'Key' in Orphan and Orphan['Key'].replace(' ','.') in OrphanList:
                    continue

                if 'Order' in Orphan:
                    if type(Orphan['Order'])==str:
                        order=json.loads(Orphan['Order'])
                        order.pop('Identity',None)
                        Orphan['Order']=order
                if 'Response' in Orphan:
                    if type(Orphan['Response'])==str:
                        resp=json.loads(Orphan['Response'])
                        Orphan['Response']=resp

                if 'Key' not in Orphan:
                    Orphan['Key']=Orphan['DateTime'].replace(' ','.')+'.'+GetID()
                else:
                    Orphan['Key']=Orphan['Key'].replace(' ','.')

                OrphanLock[Orphan['Key']]=JRRsupport.Locker(f"OliverTwist.{Orphan['Key']}.orphan")
                OrphanMemory[Orphan['Key']]=JRRsupport.Locker(f"OliverTwist.{Orphan['Key']}.memory")
                OrphanMemory[Orphan['Key']].Put(OliverTwistTimeout,"Waiting")

                Orphan['lID']=OrphanLock[Orphan['Key']].ID
                Orphan['mID']=OrphanMemory[Orphan['Key']].ID

                OrphanList[Orphan['Key']]=json.dumps(Orphan)
    StorehouseLock[Storehouse].Unlock()

# Write only when there are changes.
# Locking is done in the processor as the orphan list is being modified before saving.

def WriteOrphanList(Storehouse):
    global OrphanList

    DelList=[]
    DeleteStorehouse=StorageDirectory+'/'+Storehouse+'.delete'
    if os.path.exists(DeleteStorehouse):
        DelList=JRRsupport.ReadFile(DeleteStorehouse).strip().split('\n')

    WorkingStorehouse=StorageDirectory+'/'+Storehouse

    interceptor.Critical(True)

    fh=open(WorkingStorehouse,'w')
    for cur in OrphanList:
        data=json.loads(OrphanList[cur])
        if data['Key'] not in DelList:
            data.pop('lID',None)
            data.pop('mID',None)
            data.pop('slID',None)
            data.pop('smID',None)
            fh.write(json.dumps(data)+'\n')
    fh.close()

    if os.path.exists(DeleteStorehouse):
        os.remove(DeleteStorehouse)

    interceptor.Critical(False)

    # Process any signals received during critical section
    interceptor.SafeExit()

# This spins up the orphan manager to ensure each orphan is handled. This is NOT part of the main process, but rather a child
# process. NONE o the global or main variables are available. The ONLY information know is what is EXPLICTLY given.

# An Orphan transactor will process orphans. A relatively easy process compared to the Conditional transactor. The Condiional
# transactor will need to back feed orders into Relay, usingsimilat techniques compared to the PlaceOrder system. The
# Conditional framework will be a logistical nightmare. Emphasis has to be on speed in processing the conditions.

def ProcessOrphan(**kwargs):
    global JRLog

    # The entire kwargs payload is the orphan JSON...
    Orphan=kwargs
    State='Waiting'

    try:
        # Figure out which order processor is needed
        if Orphan['Class']=='Orphan':
            Processor=importlib.import_module(f"ORPHAN{Orphan['Framework']}")
        else:
            Processor=importlib.import_module(f"COND{Orphan['Framework']}")

        State=Processor.OrderProcessor(Orphan)
    except:
        JRLog.Write(f"Broke: {Orphan['Key']}")

    # Finish up and set the state for this order
    OrphanLock=JRRsupport.Locker(f"OliverTwist.{Orphan['Key']}.orphan",ID=Orphan['lID'])
    OrphanMemory=JRRsupport.Locker(f"OliverTwist.{Orphan['Key']}.memory",ID=Orphan['mID'])
    OrphanLock.Lock()
    OrphanMemory.Put(OliverTwistTimeout,State)
    OrphanLock.Unlock()
    print("2B:",Orphan['Key'],State)
    return None

# Process each storehouse. Handles both orphans and conditionals

def ProcessStorehouseOrder(cur):
    global NumberProcesses
#    global StorehouseLock
#    global OrphanLock
#    global OrphanMemory
#    global OrphanList
    global JRLog

    data=json.loads(cur)

    # Determine storehouse and set the lock to it.
    Storehouse=f"{data['Framework']}.{data['Order']['Exchange']}.{data['Order']['Account']}"

    # Setup locks and memory

    StorehouseLock=JRRsupport.Locker(f"OliverTwist.{Storehouse}.storehouse",ID=data['slID'])
    StorehouseMemory=JRRsupport.Locker(f"OliverTwist.{Storehouse}.memory",ID=data['smID'])

    OrphanLock=JRRsupport.Locker(f"OliverTwist.{data['Key']}.orphan",ID=data['lID'])
    OrphanMemory=JRRsupport.Locker(f"OliverTwist.{data['Key']}.memory",ID=data['mID'])

    # Get result from Locker

    OrphanLock.Lock()
    sData=json.loads(OrphanMemory.Get())
    OrphanLock.Unlock()

    if 'DataStore' in sData:
        status=sData['DataStore'].lower()
    else:
        status=sData['Status'].lower()

    print("2:",data['Key'],sData)

    # This check must contain all possible expected values.

    if status!='delete' and status!='running' and status!='notowner':
        if status=='done' \
        or status=='notfound' \
        or status=='waiting':
            status='waiting'
        else:
            JRLog.Error("Corruption",f"{data['Key']}: {sData}")

### -> Rething this situation without globals

    if status=='delete':
        StorehouseLock.Lock()
        WorkingStorehouse=StorageDirectory+'/'+Storehouse+'.delete'
        JRRsupport.AppendFile(WorkingStorehouse,data['Key']+'\n')
        StorehouseLock.Unlock()

        JRLog.Write(f"Processed {data['Class'].lower()}: {data['Key']}")
    else:
        # Only run if not already running. It is possible for this state to
        # occur, especially if there are only a few orders to process or a
        # very fast broker.

        # ID *MUST* be dynamic for security. Howver, the child process has
        # to have it in order to access the data store. orphan lock and
        # orphan memory IDs will be different.

        OrphanLock.Lock()
        if status=='waiting':
            OrphanMemory.Put(OliverTwistTimeout,"Running")
            if NumberProcesses>1:
                interceptor.StartProcess(ProcessOrphan,kwargs=data)
            else:
                ProcessOrphan(**data)
        OrphanLock.Unlock()

        # Process any signals received during critical section
        interceptor.SafeExit()

# Process a single storehouse. OrphanList is global so it can be passed to its children during the forking
# process. Process each order.

def ProcessStorehouse(*args):
    global interceptor
    global NumberProcesses
    global StorehouseLock
    global OrphanList
    global OrphanMemory
    global JRLog

    # Track signals for THIS child
    interceptor=JRRsupport.SignalInterceptor(Log=JRLog)

    Storehouse=args[0]
    lID=args[1]
    mID=args[2]

    # Load saved orphans into memory
    ReadOrphanList(Storehouse)

    print("1A:",Storehouse,len(OrphanList))
    OrphanKeys=list(OrphanList.keys())
    for cur in OrphanKeys:
        ReceiveOrphans(Storehouse)
        data=json.loads(OrphanList[cur])

        # Process a single entry
        data['slID']=lID
        data['smID']=mID
        ProcessStorehouseOrder(json.dumps(data))

        # Process any signals received during critical section
        interceptor.SafeExit()

        # Only allow "NumberProcesses" children to run as once.

        while interceptor.GetChildren()>(NumberProcesses-1):
            JRRsupport.ElasticSleep(1)

    # Wait for all orders to process
    while interceptor.GetChildren()>0:
        JRRsupport.ElasticSleep(1)

    # This storehouse is finished
    stl=JRRsupport.Locker(f"OliverTwist.{Storehouse}.storehouse",ID=lID)
    stm=JRRsupport.Locker(f"OliverTwist.{Storehouse}.memory",ID=mID)
    DeleteStorehouse=StorageDirectory+'/'+Storehouse+'.delete'
    if os.path.exists(DeleteStorehouse):
        WriteOrphanList(Storehouse)
    stl.Lock()
    stm.Put(OliverTwistTimeout,"Waiting")
    stl.Unlock()
    print("1B:",Storehouse,'Waiting')

###
### Main driver
###

def main():
    global NumberProcesses
    global StorehouseLock
    global OrphanList
    global OrphanMemory
    global JRLog

    JRLog.Write('OliverTwist '+Version)

    if len(sys.argv)>1:
        NumberProcesses=int(sys.argv[1])

    ConvertOld2New()
    JRLog.Write(f'Spawning {NumberProcesses} sub-processes per framework/exchange/account')

    while True:
        StorehouseList=os.listdir('/home/JackrabbitRelay2/Data/OliverTwist')

        for Storehouse in StorehouseList:
            # Initialize storehouse locker
            if Storehouse not in StorehouseLock:
#                print(">>> Initialize",Storehouse)
                StorehouseLock[Storehouse]=JRRsupport.Locker(f"OliverTwist.{Storehouse}.storehouse")
                StorehouseMemory[Storehouse]=JRRsupport.Locker(f"OliverTwist.{Storehouse}.memory")
                StorehouseMemory[Storehouse].Put(OliverTwistTimeout,"Waiting")

            # Get result from Locker
            StorehouseLock[Storehouse].Lock()
            sData=json.loads(StorehouseMemory[Storehouse].Get())
            StorehouseLock[Storehouse].Unlock()

            if 'DataStore' in sData:
                status=sData['DataStore'].lower()
            else:
                status=sData['Status'].lower()

            print("1:",Storehouse,sData)

            # This check must contain all possible expected values.

            if status!='running' and status!='notowner':
                if status=='done' \
                or status=='notfound' \
                or status=='waiting':
                    status='waiting'
                else:
                    JRLog.Error("Corruption",f"{Storehouse}: {sData}")

            # Only run if not already running. It is possible for this state to
            # occur, especially if there are only a few orders to process or a
            # very fast broker.

            # ID *MUST* be dynamic for security. Howver, the child process has
            # to have it in order to access the data store. orphan lock and
            # orphan memory IDs will be different.

            StorehouseLock[Storehouse].Lock()
            if status=='waiting' and 'oanda' in Storehouse:
                StorehouseMemory[Storehouse].Put(OliverTwistTimeout,"Running")
                lID=StorehouseLock[Storehouse].ID
                mID=StorehouseMemory[Storehouse].ID
                if NumberProcesses>1:
                    interceptor.StartProcess(ProcessStorehouse,args=[Storehouse,lID,mID])
                else:
                    ProcessStorehouse(Storehouse,lID,mID)
            StorehouseLock[Storehouse].Unlock()

            # Process any signals received during critical section
            interceptor.SafeExit()
        JRRsupport.ElasticSleep(1)

if __name__ == '__main__':
    main()
