#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Jackrabbit Relay
# 2021 Copyright Â© Robert APM Darin
# All rights reserved unconditionally.

import sys
sys.path.append('/home/JackrabbitRelay/Base/Library')
import os
import ccxt

import JRRconfig
import JRRlog
import JRRapi
import JRRsupport

PlaceOrderHeader='PlaceOrder FUTURE '+JRRconfig.Version

###
### Main code base. Place order on exchange
###

def main():
    JRRlog.WriteLog(PlaceOrderHeader)

    hasUSD=False
    hasBase=False
    hasQuote=False

# Get payload from STDIN and validate it

    payload=JRRsupport.pFilter(sys.stdin.read())

    Order=JRRsupport.ProcessJSON(payload)
    if Order==None:
        JRRlog.ErrorLog("Process Order","Damaged payload")

    JRRlog.WriteLog('Order Parsed')
    exchangeName=Order['Exchange'].lower()
    JRRlog.WriteLog('|- Exchange: '+exchangeName)

    market=Order['Market'].lower()
    JRRlog.WriteLog('|- Target Market: '+market)

    account=Order['Account']
    JRRlog.WriteLog('|- Account reference: '+account)

    action=Order['Action'].lower()
    JRRlog.WriteLog('|- Trade Action: '+action)

    pair=Order['Asset'].upper()
    JRRlog.WriteLog('|- Asset: '+pair)

# Check for condition size items

    if "USD" in Order:
        hasUSD=True

    if "Base" in Order:
        hasBase=True

    if "Quote" in Order:
        hasQuote=True

    if (hasUSD and hasBase) or (hasUSD and hasQuote) or (hasQuote and hasBase):
        JRRlog.ErrorLog("Quote validation","USD, Base, or Quote can be present, NOT a combination of two or more.")
    else:
        if hasUSD and '%' in Order['USD']:
            JRRlog.WriteLog('|- Using USD %')
        else:
            if hasUSD and float(Order['USD'])>0.0:
                JRRlog.WriteLog('|- Using USD')
            else:
                if hasQuote and '%' in Order['Quote']:
                    JRRlog.WriteLog('|- Using Quote %')
                else:
                    if hasQuote and float(Order['Quote'])>0.0:
                        JRRlog.WriteLog('|- Using Quote')
                    else:
                        if hasBase and float(Order['Base'])>0.0:
                            JRRlog.WriteLog('|- Using Base')

    isMinimum=False
    if (not hasUSD and not hasBase):
        isMinimum=True
        JRRlog.WriteLog('|- Using minimum position size')

# Load the API/Secret information

    keys=JRRsupport.ReadConfig(exchangeName,account)
    if keys==[]:
        JRRlog.ErrorLog("Reading Config","No API/Secret found for "+exchangeName+", (sub)account: "+account)
    else:
        JRRlog.WriteLog("API/Secret loaded for "+exchangeName+", (sub)account: "+account)

    CurrentKey=(os.getpid()%len(keys))
    Active=keys[CurrentKey]

    if len(keys)>1:
        JRRlog.WriteLog("|- Using rotating key set "+str(CurrentKey+1))

    if exchangeName in ccxt.exchanges:
        try:
            exchange=getattr(ccxt,exchangeName)( \
                { 'apiKey': Active['API'],'secret': Active['SECRET'] })
        except Exception as e:
            JRRlog.ErrorLog("Connecting to exchange",e)
    else:
        if exchangeName=="ftxus":
            try:
                exchange=ccxt.ftx({ 'hostname': 'ftx.us', \
                    'apiKey': Active['API'],'secret': Active['SECRET'] })
            except Exception as e:
                JRRlog.ErrorLog("Connecting to exchange",e)
        else:
            JRRlog.ErrorLog(exchangeName,"Exchange not supported")

# Special settings

    if "createMarketBuyOrderRequiresPrice" in exchange.options:
        JRRlog.ErrorLog(exchangeName,"Exchange not supported")

    # Set FTX and FTX US subaccount. Not sure if I need to reset API/secret yet.

    if exchangeName=="ftx" and Active['Account']!='MAIN':
        exchange.headers['FTX-SUBACCOUNT']=Active['Account']
        exchange.apiKey=Active['API']
        exchange.secret=Active['SECRET']
    else:
        if exchangeName=="ftxus" and Active['Account']!='MAIN':
            exchange.headers['FTXUS-SUBACCOUNT']=Active['Account']
            exchange.apiKey=Active['API']
            exchange.secret=Active['SECRET']

    exchange.verbose=False

    if "RateLimit" in Active:
        exchange.enableRateLimit=True
        exchange.rateLimit=int(Active['RateLimit'])
        JRRlog.WriteLog("|- Rate limit set to "+str(Active['RateLimit'])+' ms')
    else:
        exchange.enableRateLimit=False

    if "Retry" in Active:
        RetryLimit=int(Active['Retry'])
        JRRlog.WriteLog("|- API Retry limit set to "+str(RetryLimit)+' times')
    else:
        RetryLimit=1

# Check for reduce only in active config

    if "ReduceOnly" in Active:
        ReduceOnly=True
        JRRlog.WriteLog("|- ReduceOnly set ")
    else:
        ReduceOnly=False

    markets=JRRapi.GetMarkets(exchange,RetryLimit)
    JRRlog.WriteLog("Markets loaded")

    if pair[0]=='.' or pair.find(".d")>-1:
        JRRlog.ErrorLog(ExchangeName,pair+" is not tradable on this exchange")

    if pair not in exchange.markets:
        JRRlog.ErrorLog(exchangeName,pair+" is not traded on this exchange")

    if 'active' in exchange.markets[pair]:
        if exchange.markets[pair]['active']==False:
            JRRlog.ErrorLog(exchangeName,pair+" is not active on this exchange")

# Get asset information

    base=exchange.markets[pair]['base']
    quote=exchange.markets[pair]['quote']

    minimum=exchange.markets[pair]['limits']['amount']['min']
    minimum2=exchange.markets[pair]['limits']['cost']['min']
    if minimum2==None:
        minimum2=0
    minimum3=exchange.markets[pair]['limits']['price']['min']
    if minimum3==None:
        minimum3=0

    amount=minimum

    JRRlog.WriteLog("Base currency:  "+base)
    JRRlog.WriteLog("Quote currency: "+quote)

# Make USD conversion if needed
# perpetuals are USD based. Pull the balance of USD for percentages

# ADA/BTC
    if hasUSD and quote not in JRRconfig.StableCoinUSD and not isMinimum:
        bpair=JRRapi.FindMatchingPair(base,exchange.markets)
        if bpair!=None:
            ohlcv,ticker=JRRapi.FetchRetry(exchange,bpair,"1m",RetryLimit)
            JRRlog.WriteLog("Conversionm market: "+bpair)
        else:
# ADA/USDT
            if hasUSD and quote in JRRconfig.StableCoinUSD:
                ohlcv,ticker=JRRapi.FetchRetry(exchange,pair,"1m",RetryLimit)
                JRRlog.WriteLog("Getting market: "+pair)
            else:
                JRRlog.ErrorLog(exchangeName,"NO USD compatable coin for conversion reference")
    else:
# ADA/BTC Quote
        if hasQuote:
            qpair=JRRapi.FindMatchingPair(quote,exchange.markets)
            if qpair==None:
                JRRlog.ErrorLog(exchangeName,"NO compatable coin for conversion reference: "+qpair)
            JRRlog.WriteLog("Quote Conversionm market: "+qpair)
            ohlcv,ticker=JRRapi.FetchRetry(exchange,qpair,"1m",RetryLimit)
        else:
# Every thing else
            ohlcv,ticker=JRRapi.FetchRetry(exchange,pair,"1m",RetryLimit)
        JRRlog.WriteLog("Getting market: "+pair)

    if "type" in ticker['info']:
        marketType=ticker['info']['type']
    else:
        if "type" in exchange.markets[pair]:
            marketType=exchange.markets[pair]['type']
        else:
            if "permissions" in exchange.markets[pair]['info']:
                marketType=' '.join(exchange.markets[pair]['info']['permissions'])
            else:
                marketType="spot"

    if market not in marketType:
        JRRlog.ErrorLog(exchangeName, "wrong market type: "+marketType)

    if ohlcv!=[] and ohlcv!=None and type(ohlcv[4]) is float:
        close=round(ohlcv[4],6)

        if not isMinimum:
            if hasUSD:
                if '%' in Order['USD']:
                    bal=JRRapi.GetBalance(exchange,quote,RetryLimit)
                    amount=round(((float(Order['USD'].replace('%',''))/100)*bal)/close,6)
                else:
                    amount=round(float(Order['USD'])/close,6)
            else:
                if hasQuote:
                    if '%' in Order['Quote']:
                        bal=JRRapi.GetBalance(exchange,quote,RetryLimit)
                        amount=round(((float(Order['Quote'].replace('%',''))/100)*bal)/close,6)
                    else:
                        amount=round(float(Order['Quote'])/close,6)
                else:
                    amount=round(float(Order['Base']),6)

        JRRlog.WriteLog("|- Minimum: "+f'{minimum:.6f}')
        JRRlog.WriteLog("|- Amount: "+f'{amount:.6f}')

        position=JRRapi.GetPosition(exchange,pair,RetryLimit)
        if position is None:
            bal=0
        else:
            bal=position['contracts']
        sbal=f"{float(bal):.6f}"
        JRRlog.WriteLog("Previous Contracts: "+sbal+" "+pair)

# If the amount is less then the minimum and action is to sell/close

        if bal<minimum and (action=='close' or action=='sell'):
            JRRlog.ErrorLog(exchangeName, "not enough to sell/close position")

# Test to see if amount is more than balance and correct if needed

        if (amount>bal and bal>0) and (action=='close' or action=='sell'):
            JRRlog.WriteLog("|- Forcing position size")
            amount=bal

# Closing the position, with futures, we need to figure out the current
# direction and place an order opposite to it.

        if bal>0 and action=='close':
            if position['side']=='long':
                action='sell' 
            else:
                action='buy'
            JRRlog.WriteLog("|- Forcing direction to "+action)
            amount=bal

# Time to make a purchase

        if amount<minimum and action=='buy':
            JRRlog.WriteLog("|- Forcing minimum")
            amount=max(minimum,minimum2,minimum3)

# Determine trade action and carry it out

    JRRlog.WriteLog("Placing Order")
    JRRlog.WriteLog("|- Pair: "+pair)
    JRRlog.WriteLog("|- Action: "+action)
    JRRlog.WriteLog("|- Amount: "+str(amount))
    JRRlog.WriteLog("|- Close: "+str(close))
    JRRlog.WriteLog("|- Price: "+str(round(amount*close,6)))

    if action.lower()=='long':
        if ReduceOnly:
            JRRlog.WriteLog("|- ReduceOnly overide by long action")
        action='buy'
        ReduceOnly=False
    else:
        if action.lower()=='short':
            if ReduceOnly:
                JRRlog.WriteLog("|- ReduceOnly overide by short action")
            action='sell'
            ReduceOnly=False

    try: # Isolated or Crossed
        if "set_margin_mode" in exchange and "Margin" in Order:
            exchange.set_margin_mode(pair,Order['Margin'].upper())
            JRRlog.WriteLog("|- Margin: "+Order['Margin'])
    except:
        pass

    try:
        if "set_leverage" in exchange and "Leverage" in Order:
            exchange.set_legerage(int(Order['Leverage']),pair)
            JRRlog.WriteLog("|- Leverage: "+str(Order['Leverage']))
    except:
        pass

    try:
        if "Reduction" in Active and action!="buy" and amount>=bal:
            pct=Active['Reduction']
            r=(amount*pct)
            JRRlog.WriteLog("|- Reduction: "+str(r))
            amount=amount-r
    except:
        pass

    if amount>0.0:
        JRRapi.PlaceOrder(exchange,pair, 'market', action, amount, close, RetryLimit, ReduceOnly)

        position=JRRapi.GetPosition(exchange,pair,RetryLimit)
        if position is None:
            bal=0
        else:
            bal=position['contracts']
        sbal=f"{float(bal):.6f}"
        JRRlog.WriteLog("New Contracts: "+sbal+" "+pair)

# Finish with elapsed time

    JRRlog.ElapsedTime(JRRconfig.StartTime)

if __name__ == '__main__':
    main()
