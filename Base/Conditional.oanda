#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# OANDA Conditional Orders - OliverTwist

# Jackrabbit Relay
# 2021 Copyright Â© Robert APM Darin
# All rights reserved unconditionally.

# This is the framework used by OliverTwist to process conditional orders.

# Pull the actual fill price from open trades

# SellAction of Close sets Units to all and closes the entire position. Sell uses the Oanda ticket system.

import sys
sys.path.append('/home/GitHub/JackrabbitRelay/Base/Library')
import os
import json
import time

import JRRsupport
import JackrabbitRelay as JRR

# Get the order ID. If there isn't an ID, the order FAILED.

def GetOrderID(res):
    if res.find('Order Confirmation ID')>-1:
        s=res.find('ID:')+4
        for e in range(s,len(res)):
            if res[e]=='\n':
                break
        oid=res[s:e]

        return oid
    return None

# Calculate Proce Exit

def CalculatePriceExit(order,ts,dir,price):
    # Figure out TakeProfit or Stoploss
    if '%' in order[ts]:
        if dir=='long':
            val=price+((float(order[ts].replace('%','').strip())/100)*price)
        else:
            val=price-((float(order[ts].replace('%','').strip())/100)*price)
    # Pips
    elif 'p' in order['TakeProfit'].lower():
        if dir=='long':
            val=price+(float(order[ts].lower().replace('p','').strip())*0.0001)
        else:
            val=price-(float(order[ts].lower().replace('p','').strip())*0.0001)
    else:
        val=float(order[ts])

    return val

###
### Main driver
###

def main():
    data=sys.stdin.read().strip()
    Orphan=json.loads(data)

    # Use Relay to process and validate the order
    if type(Orphan['Order']) is dict:
        order=json.dumps(Orphan['Order'])
    else:
        order=Orphan['Order']

    relay=JRR.JackrabbitRelay(framework=Orphan['Framework'],payload=order)
    relay.JRLog.SetBaseName('OliverTwist')

    # Check to see if order is still open and return current state
    # Handle OANDa's weird order id sequencing
    id=Orphan['ID']
    cid=relay.GetOrderDetails(OrderID=Orphan['ID'])[-1]['id']
    saction=relay.Order['SellAction'].lower()

    # Used to determin if the asset/poition has been found
    foundPrice=False

    # Manage average and close extire position
    if saction=='close':
        positions=relay.GetPositions()
        if positions!=None:
            for pos in positions:
                if pos['instrument'].replace('_','/')==relay.Order['Asset']:
                    foundPrice=True
                    price=float(pos[dir]['averagePrice'])
                    break
    else:
        # Manage a single ticket
        openTrades=relay.GetOpenTrades(symbol=relay.Order['Asset'])

        for cur in openTrades:
            if cur['id']==cid:
                # Get the fill price from the response entry
                foundPrice=True
                price=float(cur['price'])
                break

    # Process the position
    if foundPrice==True:
        # We need to check TakeProfit and StopLoss. If one of them is hit, we need to build and order and backfeed it in
        # to Relay. It will place a new order.

        # Get the direction of the trade, long/short
        dir=relay.Order['Direction'].lower()
        # Get Ticker
        ticker=relay.GetTicker(symbol=relay.Order['Asset'])

        # Fsilsafe, in the WORST way possible. Do NOT leave a take profit out of the order. At this stage, the whole thing is
        # an absolute nightmare to fix. The is a very brutal way of dealing with poor user choices.
        if 'TakeProfit' not in relay.Order:
            relay.Order['TakeProfit']='10p'
        # Calculate Take Profit
        tp=round(CalculatePriceExit(relay.Order,'TakeProfit',dir,price),5)

        # Figure out StopLoss, if there is one
        if 'StopLoss' in relay.Order:
            sl=round(CalculatePriceExit(relay.Order,'StopLoss',dir,price),5)

        # Get the "strikePrice". This handles both TakeProfit and StopLoss. It doesn't matter which as both are processed
        # the same way.

        StrikeHappened=False
        if dir=='long':
#           relay.JRLog.Write(f"{id}: {dir} Bid: {ticker['Bid']} TP: {tp}, SL {sl}",stdOut=False)

            if ticker['Bid']>tp:
                relay.JRLog.Write(f"{id}: TP {dir} hit: {tp}",stdOut=False)
            if 'StopLoss' in relay.Order and ticker['Bid']<sl:
                relay.JRLog.Write(f"{id}: SL {dir} hit: {sl}",stdOut=False)

            if ticker['Bid']>tp or ('StopLoss' in relay.Order and ticker['Bid']<sl):
                strikePrice=ticker['Bid']
                StrikeHappened=True
        else:
#           relay.JRLog.Write(f"{id}: {dir} Ask: {ticker['Ask']} TP: {tp}, SL {sl}",stdOut=False)

            if ticker['Ask']<tp:
                relay.JRLog.Write(f"{id}: TP {dir} hit: {tp}",stdOut=False)
            if 'StopLoss' in relay.Order and ticker['Ask']>sl:
                relay.JRLog.Write(f"{id}: SL {dir} hit: {sl}",stdOut=False)

            if ticker['Ask']<tp or ('StopLoss' in relay.Order and ticker['Ask']>sl):
                strikePrice=ticker['Ask']
                StrikeHappened=True

        if StrikeHappened==True:
            # Build "strike" order. TakeProfit or StopLoss has been triggered
            newOrder={}
            newOrder['OliverTwist']='Conditional'
            newOrder['Exchange']=relay.Order['Exchange']
            newOrder['Account']=relay.Order['Account']
            newOrder['Asset']=relay.Order['Asset']
            newOrder['Action']=relay.Order['SellAction']
            newOrder['Price']=str(strikePrice)
            if saction=='close':
                # Set trade polarity
                if dir=='long':
                    newOrder['Units']='ALL'
                else:
                    newOrder['Units']='-ALL'
            else:
                newOrder['Units']=relay.Order['Units']
                newOrder['Ticket']=str(cid)
            if 'OrderType' in relay.Order:
                newOrder['OrderType']=relay.Order['OrderType']
            else:
                newOrder['OrderType']='market'
#            if 'RemapSymbol' in relay.Order:
#                newOrder['RemapSymbol']='Yes'

#            relay.JRLog.Write(f"{id}: {json.dumps(newOrder)}",stdOut=False)

            newOrder['Identity']=relay.Order['Identity']

            # Feed the new order to Relay
            result=relay.SendWebhook(newOrder)
            oid=GetOrderID(result)
            if oid!=None:
                resp=relay.GetOrderDetails(OrderID=oid)
                # Order must be closed as it succedded
                newOrder['ID']=oid
                rData={}
                rData['Key']=Orphan['Key']
                rData['lID']=Orphan['lID']
                rData['mID']=Orphan['mID']
                rData['Class']=Orphan['Class']
                rData['Status']='Delete'
                print(json.dumps(rData))
                relay.WriteLedger(Order=newOrder,Response=resp,Log=True)
            else:
                # Give OliverTwist a response
                rData={}
                rData['Key']=Orphan['Key']
                rData['lID']=Orphan['lID']
                rData['mID']=Orphan['mID']
                rData['Class']=Orphan['Class']
                rData['Status']=Orphan['Status']
                print(json.dumps(rData))
                #relay.JRLog.Write(f"{id}: {cur['state']}",stdOut=False)
            # Flush and exit
            sys.stdout.flush()
            sys.exit(0)
        else:
            # Strike did not happen
            rData={}
            rData['Key']=Orphan['Key']
            rData['lID']=Orphan['lID']
            rData['mID']=Orphan['mID']
            rData['Class']=Orphan['Class']
            rData['Status']=Orphan['Status']
            print(json.dumps(rData))
            #relay.JRLog.Write(f"{id}: {cur['state']}",stdOut=False)
            # Flush and exit
            sys.stdout.flush()
            sys.exit(0)

    # Fall through. No order matching the ID.
    rData={}
    rData['Key']=Orphan['Key']
    rData['lID']=Orphan['lID']
    rData['mID']=Orphan['mID']
    rData['Class']=Orphan['Class']
    rData['Status']="Delete"
    print(json.dumps(rData))
    sys.stdout.flush()
    #relay.JRLog.Write(f"{id}: {cur['state']}",stdOut=False)

if __name__ == '__main__':
    main()
