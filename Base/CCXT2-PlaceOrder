#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# CCXT PlaceOrder

# Jackrabbit Relay
# 2021 Copyright Â© Robert APM Darin
# All rights reserved unconditionally.

# Even though every framework can be tested in a single PlaceOrder process, its
# simply too overbloated and unneccessarily complicated. The server core already
# allows and perfers each exchange to have is own tailored PlaceOrder
# functionality. Each PlaceOrder should be optimized according to these benifits
# and should be considered time/mission critical.

import sys
sys.path.append('/home/JackrabbitRelay2/Base/Library')
import os

import JackrabbitRelay as JRR

###
### Main code base. Place order on exchange
###

def main():
    relay=JRR.JackrabbitRelay(None,sys.stdin.read())

    # If we made it this far, give our header

    relay.JRLog.Write('PlaceOrder '+relay.Version)

    # Now lets get down to business. The processed order is in:
    #    relay.Order

    relay.JRLog.Write('Order parsed')
    for detail in relay.Order:
        # Do NOT display identity
        if detail=='Identity':
            continue
        relay.JRLog.Write(f'|- {detail}: {relay.Order[detail]}')

    # Check for order type override

    if "OrderTypeOverride" in relay.Active:
        relay.Order['OrderType']=relay.Active['OrderTypeOverride'].lower()

    # Check to see if we need to remap a tradingview symbol to The Exchange symbol

    if "RemapSymbol" in relay.Active or "RemapSymbol" in relay.Order:
        relay.TradingViewRemap()

    ticker=relay.GetTicker(symbol=relay.Order['Asset'])

    # Check the spreads

    if 'SpreadOverride' in relay.Active:
        if ticker['Spread']>float(relay.Active['SpreadOverride']):
            s=f"too large, {spread:.8f} > {relay.Active['SpreadOverride']:.8f}"
            relay.JRLog.Error("Spread", s)
    if 'Spread' in relay.Order:
        if ticker['Spread']>float(relay.Order['Spread']):
            s=f"too large, {spread:.8f} > {relay.Active['SpreadOverride']:.8f}"
            relay.JRLog.Error("Spread", s)

    # Check for maximum allowed assets

    if not "OverrideMaxAssets" in relay.Order:
        if "MaxAssets" in relay.Active:
            fn=relay.DataDirectory+'/'+relay.Exchange+'.'+relay.Account
            maxAssetsList=JRRsupport.TimedList("MaxAssets",fn,int(relay.Active['MaxAssets']))
            if relay.Order['Action']`=='close':
                expire=0
            else:
                expire=(7*86400)
            results=maxAssetsList.update(relay.Order['Asset'],json.dumps(relay.Order),expire)

    # Get Minimum allowed amount (units) and cost

    isMinimum=False
    minimum,mincost=relay.GetMinimum(symbol=relay.Order['Asset'])

    # Handle various currencies and verifications

    base=relay.Markets[relay.Order['Asset']]['base'].upper()
    quote=relay.Markets[relay.Order['Asset']]['quote'].upper()

    hasUSD=False
    hasBase=False
    hasQuote=False

    # Begin breaking down different components of the order

    if "USD" in relay.Order:
        hasUSD=True

    if "Base" in relay.Order:
        hasBase=True

    if "Quote" in relay.Order:
        hasQuote=True

    # Quick sanity check to optimize preformance

    if quote=='USD' and hasQuote:
        hBase=False
        hasQuote=False
        hasUSD=True

    # Verify on one currency type for the amount.

    if (hasUSD and hasBase) or (hasUSD and hasQuote) or (hasQuote and hasBase):
        relay.JRLog.Error("Quote validation","USD, Base, or Quote can be present, NOT a combination of two or more.")
    elif hasUSD and '%' in Order['USD']:
        relay.JRLog.Write('|- Using USD %')
    elif hasUSD and float(Order['USD'])>0.0:
        relay.JRLog.Write('|- Using USD')
    elif hasQuote and '%' in Order['Quote']:
        relay.JRLog.Write('|- Using Quote %')
    elif hasQuote and float(Order['Quote'])>0.0:
        relay.JRLog.Write('|- Using Quote')
    elif hasBase and float(Order['Base'])>0.0:
        relay.JRLog.Write('|- Using Base')

    # Figure limit order pricing, minimum cost is ignored as limit orders can be
    # anything.

    if 'limit' in relay.Order['OrderType']:
        if 'Price' in relay.Order:
            o=relay.Order['Price'].lower()
            if o=='bid':
                price=round(float(ticker['Bid']),8)
            elif o=='ask':
                price=round(float(ticker['Ask']),8)
            else:
                price=round(float(relay.Order['Price']),8)
        else:
            price=round(ticker['Ask'],8)
    elif 'market' in relay.Order['OrderType']:
        # No amount method so using exchange minimum
        if (not hasUSD and not hasBase and not hasQuote):
            isMinimum=True
            amount=minimum
            price=mincost
            relay.JRLog.Write('Using minimum position amount/price')
            relay.JRLog.Write(f'|- Minimum Amount: {minimum:.8f}')
            relay.JRLog.Write(f'|- Minimum Cost:   {mincost:.8f}')
    else:
        relay.JRLog.Error("PlaceOrder", "OrderType must be limit or market")

    # Get Previous Balance

    # For CCXT, colon (:) denotes a non-Spot market (Futures).

    # Should follow Version 1 and separate spot/future market to individual
    # PlaceOrder programs.

#    if ':' in relay.Order['Asset']:
#        pBalace=relay.GetPositions(symbol=relay.Order['Asset'])
#    else:
    pBalance=relay.GetBalance(Base=base)
    relay.JRLog.Write(f"Previous Balance: {bal:.8f} {base}")

# If the amount is less then the minimum and action is to sell/close

    if pBalance<mincost and (relay.Order['Action']=='close' or relay.Order['Action']=='sell'):
        relay.JRLog.Error(relay.Exchange, "not enough to sell/close position")

# Test to see if amount is more than balance and correct in needed

    if ((relay.Order['Action']=='close' or relay.Order['Action']=='sell') \
    and (amount>pBalance and pBalance>0)) or (relay.Order['Action']=='close'):
        relay.JRLog.Write("|- Forcing balance")
        amount=pBalance

# Determine trade action and carry it out

    total=round(amount*price,8)
    relay.JRLog.Write("Placing Order")
    relay.JRLog.Write(f"|- Asset: {relay.Order['Asset']}")
    relay.JRLog.Write(f"|- Action: {relay.Order['Action']}")
    relay.JRLog.Write(f"|- Amount: {amount:.8f}")
    relay.JRLog.Write(f"|- Price: {price:.8f}")
    relay.JRLog.Write(f"|- Total: {total`:.8f}")

    try: # Isolated or Crossed
        if "set_margin_mode" in relay.Broker and "Margin" in relay.Order:
            relay.Broker.set_margin_mode(relay.Order['Asset'],relay.Order['Margin'].upper())
            relay.JRLog.Write("|- Margin: "+Order['Margin'])
    except:
        pass

    try:
        if "Reduction" in relay.Active and relay.Order['Action']!="buy" and amount>=pBalance:
            pct=relay.Active['Reduction']
            r=(amount*pct)
            relay.JRLog.Write("|- Reduction: "+str(r))
            amount-=r
    except:
        pass

    if relay.Order['Action']=='close':
        relay.Order['Action']='sell'

# In spot markets, ReduceOnly is ALWAYS false

    if amount>0:
        order=relay.PlaceOrder(pair=relay.Order['Asset'], \
            orderType=relay.Order['OrderType'], \
            action=relay.Order['Action'], \
            amount=amount, \
            price=price, \
            ReduceOnly=False, \
            LedgerNote=relay.Order['LedgerNote'])

        nBalance=relay.GetBalance(Base=base)
        relay.JRLog.Write(f"New Balance: {nBalance:.8f} {base}")
    else: # logic fault, should never happen
        relay.JRLog.Error(relay.Exchange, "can not buy/sell nothing")

    # Close out the program with the elapsed time it ran

    relay.JRLog.Elapsed()

if __name__ == '__main__':
    main()









"""


# Market Check, questionable for future usage requirements

    marketType="spot"
    if "type" in ticker['info']:
        marketType=ticker['info']['type'].lower()
    else:
        if "type" in exchange.markets[pair]:
            if "type" in exchange.markets[pair]['info']:
                if exchange.markets[pair]['info']['type']==exchange.markets[pair]['type']:
                    marketType=exchange.markets[pair]['type'].lower()
                else:
                    marketType=exchange.markets[pair]['info']['type'].lower()
        else:
            if "permissions" in exchange.markets[pair]['info']:
                marketType=' '.join(exchange.markets[pair]['info']['permissions']).lower()

    if market not in marketType:
        relay.JRLog.Error(exchangeName, "wrong market type: "+market+', asset is '+marketType)


    # Figure out percentages. AMOUNT or VOLUME to buy/sell

    if not isMinimum:
        if hasUSD:
            if '%' in Order['USD']:
                delete=(action=='close')
                if "OverridePCTtable" not in Active and "OverridePCTtable" not in Order:
                    pct,PCTtype=JRRsupport.GetPCTtype(Order['USD'])
                    amount=JRRsupport.ReadPCTValueList(exchange,account,pair,pct,PCTtype,close,delete,RetryLimit)
                else:
                    bal=JRRapi.GetBalance(exchange,quote,RetryLimit)
                    amount=round(((float(Order['USD'].replace('%',''))/100)*bal)/close,8)
            else:
                amount=round(float(Order['USD'])/close,8)
        else:
            if hasQuote:
                if '%' in Order['Quote']:
                    delete=(action=='close')
                    if "OverridePCTtable" not in Active and "OverridePCTtable" not in Order:
                        pct,PCTtype=JRRsupport.GetPCTtype(Order['Quote'])
                        amount=JRRsupport.ReadPCTValueList(exchange,account,pair,pct,PCTtype,close,delete,RetryLimit)
                    else:
                        bal=JRRapi.GetBalance(exchange,quote,RetryLimit)
                        amount=round(((float(Order['Quote'].replace('%',''))/100)*bal)/close,8)
                else:
                    amount=round(float(Order['Quote'])/close,8)
            else:
                if '%' in Order['Base']:
                    delete=(action=='close')
                    if "OverridePCTtable" not in Active and "OverridePCTtable" not in Order:
                        pct,PCTtype=JRRsupport.GetPCTtype(Order['Base'])
                        amount=JRRsupport.ReadPCTValueList(exchange,account,pair,pct,PCTtype,close,delete,RetryLimit)
                    else:
                        bal=JRRapi.GetBalance(exchange,quote,RetryLimit)
                        amount=round(((float(Order['Base'].replace('%',''))/100)*bal)/close,8)
                else:
                    amount=round(float(Order['Base']),8)

        # Make sure minimum is enforced.
        # KuCoin sub accounts do NOT verify or report correctly on this.
        if amount<minimum:
            amount=minimum

"""
