#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Jackrabbit Locker
# 2021 Copyright Â© Robert APM Darin
# All rights reserved unconditionally.

# { "ID":"DEADBWEEF", "FileName":"testData", "Action":"Lock", "Expire":"300" }

import sys
sys.path.append('/home/JackrabbitRelay2/Base/Library')
import os
import time
from datetime import datetime
import socket
import select
import json

Version="0.0.0.1.0"
BaseDirectory='/home/JackrabbitRelay2/Base'
ConfigDirectory='/home/JackrabbitRelay2/Config'
LogDirectory="/home/JackrabbitRelay2/Logs"

# Required global for the process to work

Locker={}
dataStore={}

# Write pid in port file

def WritePID(port):
    fn=BaseDirectory+'/'+str(port)+'.pid'
    f = open(fn, "w")
    f.write(str(os.getpid()))
    f.close()

# Write log entry

def WriteLog(addr,msg):
    time=(datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f'))

    s=f'{time} {addr:16} {msg}\n'

    fh=open(LogDirectory+'/JackrabbitLocker.log','a')
    fh.write(s)
    fh.close()

def ProcessPayload(data):
    global Locker
    global dataStore

    try:
        dataDB=json.loads(data)
    except: # damaged payload
        return "BadPayload\n"
    else: # Find the lock
        #pn=fds.getpeername()
        #ip=f'{pn[0]}:{pn[1]}'
        #WriteLog(ip,FileName)

        # FileName and Action are required
        if 'FileName' not in dataDB \
        or 'Action' not in dataDB:
            return "BadPayload\n"

        # Valid actions:
        #    Lock        Complete
        #    Unlock      Complete
        #    Get
        #    Put

        # What are we doing. FileName also doubles as memory ID
        FileName=dataDB['FileName']
        action=dataDB['Action'].lower()

        # Link this entry to the connected socket
        if action=='lock':
            # New request
            if FileName not in Locker:
                dataLock={}
                dataLock['ID']=dataDB['ID']
                dataLock['Expire']=time.time()+float(dataDB['Expire'])
                Locker[FileName]=dataLock
                return "Locked\n"
            # Lock has expired, now unlocked
            elif time.time()>Locker[FileName]['Expire']:
                Locker[FileName]['ID']=dataDB['ID']
                Locker[FileName]['Expire']=time.time()+float(dataDB['Expire'])
                return "Locked\n"
            else:
                if Locker[FileName]['ID']==dataDB['ID']:
                    Locker[FileName]['Expire']=time.time()+float(dataDB['Expire'])
                    return "Locked\n"
                else:
                    return "Failure\n"
        # Unlock request
        elif action=='unlock':
            # Just pass through unlocks
            if FileName not in Locker:
                return "Unlocked\n"
            # Verify owner and unlock
            elif Locker[FileName]['ID']==dataDB['ID']:
                Locker[FileName]['Expire']=0
                return "Unlocked\n"
            else:
                return "Failure\n"
            # Wrong key
        else:
            return "BadAction\n"

###
### Main Driver
###

def main():
    global Locker
    global dataStore

    port=37373

    WritePID(port)
#    WriteLog(Version,"Jackrabbit Locker")

    try:
        lockerSocket=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        lockerSocket.setblocking(0)
        lockerSocket.bind(('', port))
        lockerSocket.listen(1024)
    except OSError as err:
        x=str(err)
        if x.find('Address already in use')>-1:
            x='Another program is using this port: '+str(port)
        WriteLog(Version,x)
        sys.exit(1)

    # Track incoming connections

    inputs=[lockerSocket]

    # Response queue connected to each client

    queue={}

    while True:
        infds,outfds,errfds=select.select(inputs, inputs, [], 5)

        if len(infds)!=0:
            for fds in infds:
                if fds is lockerSocket:
                    clientsock,clientaddr=fds.accept()
                    clientsock.setblocking(0)
                    if clientsock not in inputs:
                        inputs.append(clientsock)
                    dataStore[clientsock]=''
                else:
                    data=None
                    try:
                        data=fds.recv(1024)
                    except:
                        pass

                    # No data received, close connection

                    if not data:
                        if fds in inputs:
                            inputs.remove(fds)
                        if fds in queue:
                            queue.pop(fds,None)
                        fds.close()
                        now=time.time()
                        for k in list(Locker):
                            if now>Locker[k]['Expire']:
                                Locker.pop(k,None)
                    else:
                        data=data.decode()
                        dataStore[fds]+=data
                        if data[-1]=='\n':
                            queue[fds]=ProcessPayload(dataStore[fds])

        # Send response and close connection

        if len(outfds)!=0:
            for fds in outfds:
                if fds in queue:
                    try:
                        #pn=fds.getpeername()
                        #ip=f'{pn[0]}:{pn[1]}
                        #print("S:",queue[fds].strip())
                        fds.sendall(queue[fds].encode())
                    except:
                        if fds in inputs:
                            inputs.remove(fds)
                        fds.close()
                    queue.pop(fds,None)

if __name__ == '__main__':
    main()
